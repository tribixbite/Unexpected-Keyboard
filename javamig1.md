ğŸ§‘â€ğŸ’» ## USER

This is the Gemini CLI. We are setting up the context for our chat.
Today's date is Tuesday, November 25, 2025 (formatted according to the user's locale).
My operating system is: android
The project's temporary directory is: /data/data/com.termux/files/home/.gemini/tmp/2e417ecfaf5a239fbd01d4d79ea5b607b6a0a841f66df5744fa31de9356f7209
I'm currently working in the directory: /data/data/com.termux/files/home/git/swype/Unexpected-Keyboard
Here is the folder structure of the current working directories:

Showing up to 200 items (files + folders). Folders or files indicated with ... contain more items not shown, were ignored, or the display limit (200 items) was reached.

/data/data/com.termux/files/home/git/swype/Unexpected-Keyboard/
â”œâ”€â”€â”€ contractions-2025-11-02-this-session-is-being-continued-from-a-previous-co.txt
â”œâ”€â”€â”€.gitattributes
â”œâ”€â”€â”€.gitignore
â”œâ”€â”€â”€50k_words.json
â”œâ”€â”€â”€700
â”œâ”€â”€â”€adb-wireless-connect.sh
â”œâ”€â”€â”€ADVANCED_PREDICTION_SETTINGS.md
â”œâ”€â”€â”€alphabs_benchmark_plan.md
â”œâ”€â”€â”€alphabs.md
â”œâ”€â”€â”€analyze_swipe_data.py
â”œâ”€â”€â”€AndroidManifest.xml
â”œâ”€â”€â”€AUDIT_VERIFICATION.md
â”œâ”€â”€â”€BEAM_SEARCH_AUDIT.md
â”œâ”€â”€â”€BEAM_SEARCH_SCORING_ANALYSIS.md
â”œâ”€â”€â”€beam.md
â”œâ”€â”€â”€bottleneck_lag_final.md
â”œâ”€â”€â”€bottleneck_report.md
â”œâ”€â”€â”€build-debug.log
â”œâ”€â”€â”€build-on-termux.sh
â”œâ”€â”€â”€build-phase3.log
â”œâ”€â”€â”€build-release.log
â”œâ”€â”€â”€build-test-deploy.sh
â”œâ”€â”€â”€build-thread-safety.log
â”œâ”€â”€â”€build.gradle
â”œâ”€â”€â”€build.log
â”œâ”€â”€â”€check_app_status.sh
â”œâ”€â”€â”€check_calibration_logs.sh
â”œâ”€â”€â”€check_layout.output
â”œâ”€â”€â”€check_layout.py
â”œâ”€â”€â”€check_swipe_logs.sh
â”œâ”€â”€â”€check_termux_lag.sh
â”œâ”€â”€â”€CLAUDE.md
â”œâ”€â”€â”€clipboard-architecture-fix-2025-11-05.md
â”œâ”€â”€â”€clipboard-expansion-2025-11-06-command-messagezenreview-mcp-is-runningcom.txt
â”œâ”€â”€â”€clipboard-expert-2025-11-05-command-messagezenreview-mcp-is-runningcom.txt
â”œâ”€â”€â”€clipboard-fix-2025-11-05.md
â”œâ”€â”€â”€clipboard-search-keyboard-routing-2025-11-05.txt
â”œâ”€â”€â”€COMPLETION_SUMMARY.md
â”œâ”€â”€â”€CONTRIBUTING.md
â”œâ”€â”€â”€crash_analysis.md
â”œâ”€â”€â”€crash_dump.txt
â”œâ”€â”€â”€crash.txt
â”œâ”€â”€â”€CRITICAL_RESAMPLING_BUG.md
â”œâ”€â”€â”€debug_template_matching.py
â”œâ”€â”€â”€deduplicate_contractions.py
â”œâ”€â”€â”€deletewordss2025-11-03-add-or-to-os-west-short-swipe-system-at-to.txt
â”œâ”€â”€â”€deployment-test.log
â”œâ”€â”€â”€devinfo.txt
â”œâ”€â”€â”€FINAL_SMOOTHING_SOLUTION.md
â”œâ”€â”€â”€find.md
â”œâ”€â”€â”€fix-aapt2.sh
â”œâ”€â”€â”€frequencydict2025-10-21-this-session-is-being-continued-from-a-previous-co.txt
â”œâ”€â”€â”€funding.json
â”œâ”€â”€â”€FUNDING.yml
â”œâ”€â”€â”€gemini.md
â”œâ”€â”€â”€gen_emoji.py
â”œâ”€â”€â”€gen_layouts.py
â”œâ”€â”€â”€gen_sinhala_phonetic_layout.py
â”œâ”€â”€â”€generate_code_metrics.sh
â”œâ”€â”€â”€get_play_certificates.py
â”œâ”€â”€â”€GITHUB_KEYSTORE_SETUP.md
â”œâ”€â”€â”€gradle.properties
â”œâ”€â”€â”€gradlew
â”œâ”€â”€â”€gradlew.bat
â”œâ”€â”€â”€IMPLEMENTATION_COMPLETE.md
â”œâ”€â”€â”€inertion2025-10-19-this-session-is-being-continued-from-a-previous-co.txt
â”œâ”€â”€â”€inferencebugs1.md
â”œâ”€â”€â”€install-via-adb.sh
â”œâ”€â”€â”€install.sh
â”œâ”€â”€â”€investigation_lag.md
â”œâ”€â”€â”€investigation_report.md
â”œâ”€â”€â”€iterate_neural_test.sh
â”œâ”€â”€â”€large_crash_dump.txt
â”œâ”€â”€â”€latency_analysis.md
â”œâ”€â”€â”€LATENCY_OPTIMIZATION_PLAN.md
â”œâ”€â”€â”€LICENSE
â”œâ”€â”€â”€lock_optimization_verification.md
â”œâ”€â”€â”€mainthreadfix.md
â”œâ”€â”€â”€minimal_test.class
â”œâ”€â”€â”€minimal_test.java
â”œâ”€â”€â”€NEURAL_PERFORMANCE_SUMMARY.md
â”œâ”€â”€â”€nn-expert-src-mask-2025-11-05-this-session-is-being-continued-from-a-previous-co.txt
â”œâ”€â”€â”€nopred3.txt
â”œâ”€â”€â”€nopred4.txt
â”œâ”€â”€â”€nopred5.txt
â”œâ”€â”€â”€ONNX_Hardware_Acceleration_Expert_Consultation.md
â”œâ”€â”€â”€OVERZEALOUS_GENEALOGY_ANALYSIS.md
â”œâ”€â”€â”€perftodos.md
â”œâ”€â”€â”€perftodos2.md
â”œâ”€â”€â”€perftodos3.md
â”œâ”€â”€â”€perftodos4.md
â”œâ”€â”€â”€perftodos5.md
â”œâ”€â”€â”€perftodos6.md
â”œâ”€â”€â”€pre-commit-tests.sh
â”œâ”€â”€â”€process_contractions.py
â”œâ”€â”€â”€PUSH_SUMMARY_v1.32.644.md
â”œâ”€â”€â”€QUANTIZATION_IMPLEMENTATION_PLAN.md
â”œâ”€â”€â”€README.md
â”œâ”€â”€â”€refactor.md
â”œâ”€â”€â”€regenerate_txt_dictionary.py
â”œâ”€â”€â”€resampling_caching_report.md
â”œâ”€â”€â”€RESAMPLING_DEBUG_SESSION.md
â”œâ”€â”€â”€RESAMPLING_TEST_PLAN.md
â”œâ”€â”€â”€RESAMPLING_WORKS.md
â”œâ”€â”€â”€run_benchmark.sh
â”œâ”€â”€â”€SESSION_FINAL_v1.32.644.md
â”œâ”€â”€â”€SESSION_SUMMARY_2025-11-23.md
â”œâ”€â”€â”€settings.gradle
â”œâ”€â”€â”€setup-arm64-buildtools.sh
â”œâ”€â”€â”€shell.nix
â”œâ”€â”€â”€shortcuts-2025-11-02.txt
â”œâ”€â”€â”€smoke-test.sh
â”œâ”€â”€â”€SMOOTHING_WINDOW_1_TEST.md
â”œâ”€â”€â”€SMOOTHING_WINDOW_ANALYSIS.md
â”œâ”€â”€â”€smoothing-explanation.txt
â”œâ”€â”€â”€sstwochar2025-10-19-this-session-is-being-continued-from-a-previous-co.txt
â”œâ”€â”€â”€STATE_SUMMARY_v1.32.643.md
â”œâ”€â”€â”€STATUS.md
â”œâ”€â”€â”€swipe_data_20250821_235946.json
â”œâ”€â”€â”€SWIPE_LAG_DEBUG.md
â”œâ”€â”€â”€sync_translations.py
â”œâ”€â”€â”€termux-fix-2025-11-03.txt
â”œâ”€â”€â”€termux-fixes-complete-2025-11-03.txt
â”œâ”€â”€â”€test_logic.class
â”œâ”€â”€â”€test_logic.java
â”œâ”€â”€â”€test_neural_iterations.sh
â”œâ”€â”€â”€test_neural.py
â”œâ”€â”€â”€test_onnx_cli.py
â”œâ”€â”€â”€test_predictions.py
â”œâ”€â”€â”€TEST_SUITE_SUMMARY.md
â”œâ”€â”€â”€test_swipe_improvements.py
â”œâ”€â”€â”€test_tensor_ops.py
â”œâ”€â”€â”€test-results.log
â”œâ”€â”€â”€TestNeuralPipelineCLI.java
â”œâ”€â”€â”€TestNeuralSystem.java
â”œâ”€â”€â”€TestOnnxDirect.class
â”œâ”€â”€â”€TestOnnxDirect.java
â”œâ”€â”€â”€TestOnnxDirect$IndexValue.class
â”œâ”€â”€â”€thread-safety-analysis.md
â”œâ”€â”€â”€trie.md
â”œâ”€â”€â”€trie2.md
â”œâ”€â”€â”€ui_optimization_verification.md
â”œâ”€â”€â”€uninstall-debug.sh
â”œâ”€â”€â”€upload-keystore.jks
â”œâ”€â”€â”€UTILITY_SCRIPTS.md
â”œâ”€â”€â”€VOCAB_CACHE_FIX.md
â”œâ”€â”€â”€WEB_DEMO_FLOW.md
â”œâ”€â”€â”€worddeletetermux2025-11-03-add-or-to-os-west-short-swipe-system-at-to.txt
â”œâ”€â”€â”€WORK_COMPLETE.md
â”œâ”€â”€â”€.git/...
â”œâ”€â”€â”€.github/
â”‚   â””â”€â”€â”€workflows/
â”œâ”€â”€â”€.gradle/...
â”œâ”€â”€â”€.serena/
â”‚   â”œâ”€â”€â”€.gitignore
â”‚   â””â”€â”€â”€project.yml
â”œâ”€â”€â”€archive/
â”‚   â””â”€â”€â”€old-dtw-system/
â”œâ”€â”€â”€assets/
â”‚   â”œâ”€â”€â”€libjni_latinimegoogle.so
â”‚   â”œâ”€â”€â”€special_font.ttf
â”‚   â”œâ”€â”€â”€dictionaries/
â”‚   â””â”€â”€â”€models/
â”œâ”€â”€â”€build/...
â”œâ”€â”€â”€doc/
â”‚   â”œâ”€â”€â”€cgr.pdf
â”‚   â”œâ”€â”€â”€Custom-layouts.md
â”‚   â””â”€â”€â”€Possible-key-values.md
â”œâ”€â”€â”€docs/
â”‚   â”œâ”€â”€â”€AVOIDING_INTEGRATION_ISSUES.md
â”‚   â”œâ”€â”€â”€hybrid-contraction-system.md
â”‚   â”œâ”€â”€â”€KEYBOARD2_REFACTORING_PLAN.md
â”‚   â”œâ”€â”€â”€NN_FIXES_SUMMARY_v1.32.339-340.md
â”‚   â”œâ”€â”€â”€NN_SETTINGS_GUIDE.md
â”‚   â”œâ”€â”€â”€performance-bottlenecks.md
â”‚   â”œâ”€â”€â”€SESSION_SUMMARY_v1.32.415.md
â”‚   â”œâ”€â”€â”€TESTING_CHECKLIST.md
â”‚   â”œâ”€â”€â”€TESTING_STATUS.md
â”‚   â”œâ”€â”€â”€TESTING.md
â”‚   â”œâ”€â”€â”€dictionaries/
â”‚   â”œâ”€â”€â”€nn_train/
â”‚   â”œâ”€â”€â”€refactoring/
â”‚   â”œâ”€â”€â”€review/
â”‚   â””â”€â”€â”€specs/
â”œâ”€â”€â”€fastlane/
â”‚   â””â”€â”€â”€metadata/
â”œâ”€â”€â”€floris/
â”‚   â”œâ”€â”€â”€GlideTypingClassifier.kt
â”‚   â”œâ”€â”€â”€GlideTypingGesture.kt
â”‚   â””â”€â”€â”€GlideTypingManager.kt
â”‚   â””â”€â”€â”€...
â”œâ”€â”€â”€gradle/
â”œâ”€â”€â”€memory/
â”œâ”€â”€â”€ml_training/
â”œâ”€â”€â”€models/
â”œâ”€â”€â”€res/
â”œâ”€â”€â”€scripts/
â”œâ”€â”€â”€srcs/
â”œâ”€â”€â”€test/
â”œâ”€â”€â”€tools/
â””â”€â”€â”€web_demo/

Reminder: Do not return an empty response when a tool call is required.

My setup is complete. I will provide my first command in the next turn.

---

ğŸ§‘â€ğŸ’» ## USER

<state_snapshot>
    <overall_goal>
        Complete the migration of the neural swipe prediction engine from the monolithic `OnnxSwipePredictor.java` to a modular Kotlin architecture (`SwipePredictorOrchestrator`).
    </overall_goal>

    <key_knowledge>
        - **Architecture Change:** `OnnxSwipePredictor.java` has been deleted. The new entry point is `juloo.keyboard2.onnx.SwipePredictorOrchestrator` (Kotlin).
        - **Components:**
            - `ModelLoader`: Handles ONNX sessions and hardware acceleration config.
            - `EncoderWrapper`/`DecoderWrapper`: Encapsulate inference.
            - `BeamSearchEngine`: Implements the search logic.
            - `PredictionPostProcessor`: Handles vocabulary filtering and scoring.
        - **Models:** Uses V4 INT8 quantized models (`swipe_encoder_android.onnx`, `swipe_decoder_android.onnx`).
        - **Data Types:** Input tensors now strictly require `IntBuffer` (not `LongBuffer`) due to model quantization.
        - **Build:** `./build-on-termux.sh` was successful (Version 1.32.694).
        - **APK:** Located at `build/outputs/apk/debug/juloo.keyboard2.debug.apk` and copied to `/storage/emulated/0/unexpected/`.
    </key_knowledge>

    <file_system_state>
        - DELETED: `srcs/juloo.keyboard2/OnnxSwipePredictor.java`
        - MODIFIED: `srcs/juloo.keyboard2/NeuralSwipeTypingEngine.java` (now delegates to `SwipePredictorOrchestrator`).
        - MODIFIED: `srcs/juloo.keyboard2/DictionaryManagerActivity.kt` (updated vocabulary reload call).
        - MODIFIED: `TestNeuralPipelineCLI.java`, `TestNeuralSystem.java`, `TestOnnxDirect.java`, `srcs/androidTest/java/juloo/keyboard2/OnnxBenchmarkTest.java` (updated paths and types).
        - UPDATED: `WORK_COMPLETE.md` with migration details.
    </file_system_state>

    <recent_actions>
        - Updated `NeuralSwipeTypingEngine` to bridge the new Kotlin API with the existing Java codebase (handling `List<Float>` to `List<Integer>` conversion).
        - Fixed `DictionaryManagerActivity` to use the new orchestrator singleton.
        - Updated all standalone Java CLI tests to use `IntBuffer` and correct asset paths.
        - Deleted `OnnxSwipePredictor.java`.
        - Successfully built the project (`v1.32.694`).
    </recent_actions>

    <current_plan>
        1. [DONE] Refactor `OnnxSwipePredictor` into Kotlin modules.
        2. [DONE] Update consumers (`NeuralSwipeTypingEngine`, `DictionaryManagerActivity`).
        3. [DONE] Update and verify tests.
        4. [DONE] Delete legacy Java file.
        5. [DONE] Build and verify.
        6. [NEXT] User to install APK and verify swipe functionality in-app.
    </current_plan>
</state_snapshot>

---

âœ¨ ## MODEL

Got it. Thanks for the additional context!

---

ğŸ§‘â€ğŸ’» ## USER

great! now do SettingsActivity.java

---

âœ¨ ## MODEL

**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "srcs/juloo.keyboard2/SettingsActivity.java"
  }
}
```

---

ğŸ§‘â€ğŸ’» ## USER

**Tool Response**:
```json
{
  "id": "read_file-1764078508490-b2dead7af03468",
  "name": "read_file",
  "response": {
    "output": "\nIMPORTANT: The file content has been truncated.\nStatus: Showing lines 1-2000 of 2052 total lines.\nAction: To read more of the file, you can use the 'offset' and 'limit' parameters in a subsequent 'read_file' call. For example, to read the next section of the file, use offset: 2000.\n\n--- FILE CONTENT (truncated) ---\npackage juloo.keyboard2;\n\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.res.Configuration;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.preference.Preference;\nimport android.preference.PreferenceActivity;\nimport android.preference.PreferenceManager;\nimport android.util.Log;\nimport android.widget.Toast;\nimport java.io.File;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.Properties;\nimport juloo.keyboard2.ml.SwipeMLDataStore;\nimport juloo.keyboard2.ml.SwipeMLTrainer;\nimport android.app.ProgressDialog;\n\npublic class SettingsActivity extends PreferenceActivity\n  implements SharedPreferences.OnSharedPreferenceChangeListener\n{\n  // Request codes for backup/restore file picker\n  private static final int REQUEST_CODE_BACKUP = 1001;\n  private static final int REQUEST_CODE_RESTORE = 1002;\n  private static final int REQUEST_CODE_NEURAL_ENCODER = 1003;\n  private static final int REQUEST_CODE_NEURAL_DECODER = 1004;\n  private static final int REQUEST_CODE_EXPORT_CUSTOM_DICT = 1006;\n  private static final int REQUEST_CODE_IMPORT_CUSTOM_DICT = 1007;\n  private static final int REQUEST_CODE_EXPORT_CLIPBOARD = 1008;\n  private static final int REQUEST_CODE_IMPORT_CLIPBOARD = 1009;\n\n  private BackupRestoreManager backupRestoreManager;\n\n  @Override\n  public void onCreate(Bundle savedInstanceState)\n  {\n    super.onCreate(savedInstanceState);\n    // The preferences can't be read when in direct-boot mode. Avoid crashing\n    // and don't allow changing the settings.\n    // Run the config migration on this prefs as it might be different from the\n    // one used by the keyboard, which have been migrated.\n    try\n    {\n      SharedPreferences prefs = getPreferenceManager().getSharedPreferences();\n      // Repair corrupted float preferences before loading preference UI\n      Config.repairCorruptedFloatPreferences(prefs);\n      Config.migrate(prefs);\n    }\n    catch (Exception _e) { fallbackEncrypted(); return; }\n    addPreferencesFromResource(R.xml.settings);\n\n    // Initialize backup/restore manager\n    backupRestoreManager = new BackupRestoreManager(this);\n\n    // Setup backup/restore preference handlers\n    setupBackupRestoreHandlers();\n\n    // Add CGR reset button handlers and update summaries\n    setupCGRResetButtons();\n    updateCGRParameterSummaries();\n\n    boolean foldableDevice = FoldStateTracker.isFoldableDevice(this);\n    findPreference(\"margin_bottom_portrait_unfolded\").setEnabled(foldableDevice);\n    findPreference(\"margin_bottom_landscape_unfolded\").setEnabled(foldableDevice);\n    findPreference(\"horizontal_margin_portrait_unfolded\").setEnabled(foldableDevice);\n    findPreference(\"horizontal_margin_landscape_unfolded\").setEnabled(foldableDevice);\n    findPreference(\"keyboard_height_unfolded\").setEnabled(foldableDevice);\n    findPreference(\"keyboard_height_landscape_unfolded\").setEnabled(foldableDevice);\n    \n    // Add version info display\n    Preference versionPref = findPreference(\"version_info\");\n    if (versionPref != null)\n    {\n      try\n      {\n        Properties versionInfo = loadVersionInfo();\n        String commit = versionInfo.getProperty(\"commit\", \"unknown\");\n        String commitDate = versionInfo.getProperty(\"commit_date\", \"\");\n        String buildDate = versionInfo.getProperty(\"build_date\", \"\");\n        String buildNumber = versionInfo.getProperty(\"build_number\", \"\");\n        \n        versionPref.setTitle(\"Version Info\");\n        versionPref.setSummary(String.format(\"Build: %s\\nCommit: %s (%s)\\nBuilt: %s\",\n          buildNumber.substring(Math.max(0, buildNumber.length() - 8)),\n          commit, commitDate, buildDate));\n      }\n      catch (Exception e)\n      {\n        versionPref.setSummary(\"Version info unavailable\");\n        android.util.Log.e(\"SettingsActivity\", \"Failed to load version info\", e);\n      }\n    }\n\n    // Update clipboard storage stats\n    updateClipboardStats();\n\n    // Add update button\n    Preference updatePref = findPreference(\"update_app\");\n    if (updatePref != null)\n    {\n      updatePref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          installUpdate();\n          return true;\n        }\n      });\n    }\n    \n    // Set up calibration preference click handler\n    Preference calibrationPref = findPreference(\"swipe_calibration\");\n    if (calibrationPref != null)\n    {\n      calibrationPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          Intent intent = new Intent(SettingsActivity.this, SwipeCalibrationActivity.class);\n          startActivity(intent);\n          return true;\n        }\n      });\n    }\n\n    // Set up debug preference click handler\n    Preference debugPref = findPreference(\"swipe_debug\");\n    if (debugPref != null)\n    {\n      debugPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          Intent intent = new Intent(SettingsActivity.this, SwipeDebugActivity.class);\n          startActivity(intent);\n          return true;\n        }\n      });\n    }\n\n    // Set up dictionary manager preference click handler\n    Preference dictionaryManagerPref = findPreference(\"dictionary_manager\");\n    if (dictionaryManagerPref != null)\n    {\n      dictionaryManagerPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          Intent intent = new Intent(SettingsActivity.this, DictionaryManagerActivity.class);\n          startActivity(intent);\n          return true;\n        }\n      });\n    }\n\n    // Set up ML data export preference (PreferenceScreen type)\n    Preference exportMLDataPref = findPreference(\"export_swipe_ml_data\");\n    if (exportMLDataPref != null)\n    {\n      try\n      {\n        // Update summary with current data statistics\n        SwipeMLDataStore dataStore = SwipeMLDataStore.getInstance(this);\n        SwipeMLDataStore.DataStatistics stats = dataStore.getStatistics();\n        exportMLDataPref.setSummary(\"Export all collected swipe data (\" + stats.totalCount + \" samples)\");\n      }\n      catch (Exception e)\n      {\n        exportMLDataPref.setSummary(\"Export all collected swipe data\");\n        android.util.Log.e(\"SettingsActivity\", \"Failed to get ML data statistics\", e);\n      }\n      \n      exportMLDataPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          exportSwipeMLData();\n          return true;\n        }\n      });\n    }\n    \n    // Import ML Data\n    Preference importMLDataPref = findPreference(\"import_swipe_ml_data\");\n    if (importMLDataPref != null)\n    {\n      importMLDataPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          importSwipeMLData();\n          return true;\n        }\n      });\n    }\n    \n    // Set up ML training preference (PreferenceScreen type)\n    Preference trainMLModelPref = findPreference(\"train_swipe_ml_model\");\n    if (trainMLModelPref != null)\n    {\n      try\n      {\n        SwipeMLDataStore dataStore = SwipeMLDataStore.getInstance(this);\n        SwipeMLDataStore.DataStatistics stats = dataStore.getStatistics();\n        trainMLModelPref.setSummary(\"Train model with \" + stats.totalCount + \" samples (min 100 required)\");\n      }\n      catch (Exception e)\n      {\n        trainMLModelPref.setSummary(\"Train swipe prediction model\");\n        android.util.Log.e(\"SettingsActivity\", \"Failed to get ML data statistics\", e);\n      }\n      \n      trainMLModelPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          startMLTraining();\n          return true;\n        }\n      });\n    }\n\n    // Set up model version change listener to update info display\n    Preference modelVersionPref = findPreference(\"neural_model_version\");\n    if (modelVersionPref != null)\n    {\n      modelVersionPref.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener()\n      {\n        @Override\n        public boolean onPreferenceChange(Preference preference, Object newValue)\n        {\n          // Update model info display after a short delay to let preference save\n          new android.os.Handler().postDelayed(new Runnable()\n          {\n            @Override\n            public void run()\n            {\n              updateNeuralModelInfo();\n            }\n          }, 100);\n          return true;\n        }\n      });\n    }\n\n    // Set up neural model file pickers\n    Preference loadEncoderPref = findPreference(\"neural_load_encoder\");\n    if (loadEncoderPref != null)\n    {\n      loadEncoderPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          openFilePicker(REQUEST_CODE_NEURAL_ENCODER);\n          return true;\n        }\n      });\n      // Update summary with current file\n      updateModelFileSummary(loadEncoderPref, \"neural_custom_encoder_uri\");\n    }\n\n    Preference loadDecoderPref = findPreference(\"neural_load_decoder\");\n    if (loadDecoderPref != null)\n    {\n      loadDecoderPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          openFilePicker(REQUEST_CODE_NEURAL_DECODER);\n          return true;\n        }\n      });\n      // Update summary with current file\n      updateModelFileSummary(loadDecoderPref, \"neural_custom_decoder_uri\");\n    }\n\n    // Update neural model info display\n    updateNeuralModelInfo();\n  }\n\n  private void updateNeuralModelInfo()\n  {\n    Preference modelInfoPref = findPreference(\"neural_model_info\");\n    if (modelInfoPref != null)\n    {\n      try\n      {\n        SharedPreferences prefs = getPreferenceManager().getSharedPreferences();\n        String modelVersion = prefs.getString(\"neural_model_version\", \"v2\");\n        String encoderUri = prefs.getString(\"neural_custom_encoder_uri\", null);\n        String decoderUri = prefs.getString(\"neural_custom_decoder_uri\", null);\n\n        StringBuilder summary = new StringBuilder();\n\n        if (\"custom\".equals(modelVersion))\n        {\n          // Custom model mode\n          if (encoderUri != null && decoderUri != null)\n          {\n            summary.append(\"âœ… Custom models selected\\n\");\n            summary.append(\"Will load on next swipe (may take ~5s first time)\");\n          }\n          else if (encoderUri != null)\n          {\n            summary.append(\"âš ï¸ Only encoder selected\\nNeed decoder file too\");\n          }\n          else if (decoderUri != null)\n          {\n            summary.append(\"âš ï¸ Only decoder selected\\nNeed encoder file too\");\n          }\n          else\n          {\n            summary.append(\"âš ï¸ No custom files selected\\nUse file pickers below\");\n          }\n        }\n        else\n        {\n          // v2 builtin model\n          summary.append(\"âœ… Built-in model (v2)\\n\");\n          summary.append(\"250-length, 80.6% accuracy, ready to use\");\n        }\n\n        modelInfoPref.setSummary(summary.toString());\n      }\n      catch (Exception e)\n      {\n        modelInfoPref.setSummary(\"âŒ Error loading model info\");\n        android.util.Log.e(\"SettingsActivity\", \"Failed to get model info\", e);\n      }\n    }\n  }\n\n  private void exportSwipeMLData()\n  {\n    try\n    {\n      SwipeMLDataStore dataStore = SwipeMLDataStore.getInstance(this);\n      SwipeMLDataStore.DataStatistics stats = dataStore.getStatistics();\n      \n      if (stats.totalCount == 0)\n      {\n        Toast.makeText(this, \"No swipe data to export\", Toast.LENGTH_SHORT).show();\n        return;\n      }\n      \n      // Export to JSON file\n      File exportFile = dataStore.exportToJSON();\n      \n      // Show success message with file location\n      String message = \"Exported \" + stats.totalCount + \" swipe samples\\n\\n\" +\n                      \"File saved to:\\n\" + exportFile.getAbsolutePath() + \"\\n\\n\" +\n                      \"Statistics:\\n\" +\n                      \"â€¢ Calibration samples: \" + stats.calibrationCount + \"\\n\" +\n                      \"â€¢ User samples: \" + stats.userSelectionCount + \"\\n\" +\n                      \"â€¢ Unique words: \" + stats.uniqueWords;\n      \n      // Create alert dialog to show export info\n      android.app.AlertDialog.Builder builder = new android.app.AlertDialog.Builder(this);\n      builder.setTitle(\"Export Successful\");\n      builder.setMessage(message);\n      builder.setPositiveButton(\"OK\", null);\n      \n      // Add copy path button\n      builder.setNeutralButton(\"Copy Path\", (dialog, which) -> {\n        android.content.ClipboardManager clipboard = \n          (android.content.ClipboardManager) getSystemService(android.content.Context.CLIPBOARD_SERVICE);\n        android.content.ClipData clip = android.content.ClipData.newPlainText(\"Export Path\", exportFile.getAbsolutePath());\n        clipboard.setPrimaryClip(clip);\n        Toast.makeText(this, \"Path copied to clipboard\", Toast.LENGTH_SHORT).show();\n      });\n      \n      builder.show();\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Export failed: \" + e.getMessage(), Toast.LENGTH_LONG).show();\n      android.util.Log.e(\"SettingsActivity\", \"Failed to export ML data\", e);\n    }\n  }\n  \n  private void importSwipeMLData()\n  {\n    // Create file picker dialog\n    android.app.AlertDialog.Builder builder = new android.app.AlertDialog.Builder(this);\n    builder.setTitle(\"Import Swipe Data\");\n    builder.setMessage(\"Select JSON file to import from:\");\n    \n    // Check common locations for exported files\n    File[] possibleFiles = new File[] {\n      new File(\"/sdcard/Android/data/juloo.keyboard2.debug/files/swipe_ml_export/\"),\n      new File(\"/storage/emulated/0/Android/data/juloo.keyboard2.debug/files/swipe_ml_export/\"),\n      new File(\"/sdcard/Download/\"),\n      new File(\"/storage/emulated/0/Download/\")\n    };\n    \n    // Find existing JSON files\n    java.util.List<File> jsonFiles = new java.util.ArrayList<>();\n    for (File dir : possibleFiles)\n    {\n      if (dir.exists() && dir.isDirectory())\n      {\n        File[] files = dir.listFiles((dir1, name) -> name.endsWith(\".json\"));\n        if (files != null)\n        {\n          for (File f : files)\n          {\n            jsonFiles.add(f);\n          }\n        }\n      }\n    }\n    \n    if (jsonFiles.isEmpty())\n    {\n      Toast.makeText(this, \"No JSON files found in common locations\", Toast.LENGTH_LONG).show();\n      return;\n    }\n    \n    // Create list of file names\n    String[] fileNames = new String[jsonFiles.size()];\n    for (int i = 0; i < jsonFiles.size(); i++)\n    {\n      fileNames[i] = jsonFiles.get(i).getName() + \"\\n(\" + jsonFiles.get(i).getParent() + \")\";\n    }\n    \n    builder.setItems(fileNames, (dialog, which) -> {\n      File selectedFile = jsonFiles.get(which);\n      performImport(selectedFile);\n    });\n    \n    builder.setNegativeButton(\"Cancel\", null);\n    builder.show();\n  }\n  \n  private void performImport(File jsonFile)\n  {\n    try\n    {\n      SwipeMLDataStore dataStore = SwipeMLDataStore.getInstance(this);\n      int importedCount = dataStore.importFromJSON(jsonFile);\n      \n      if (importedCount > 0)\n      {\n        Toast.makeText(this, \"Successfully imported \" + importedCount + \" swipe samples\", \n                      Toast.LENGTH_LONG).show();\n        \n        // Update export preference summary\n        Preference exportPref = findPreference(\"export_swipe_ml_data\");\n        if (exportPref != null)\n        {\n          SwipeMLDataStore.DataStatistics stats = dataStore.getStatistics();\n          exportPref.setSummary(\"Export all collected swipe data (\" + stats.totalCount + \" samples)\");\n        }\n      }\n      else\n      {\n        Toast.makeText(this, \"No new samples imported (duplicates skipped)\", Toast.LENGTH_SHORT).show();\n      }\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Import failed: \" + e.getMessage(), Toast.LENGTH_LONG).show();\n      android.util.Log.e(\"SettingsActivity\", \"Failed to import ML data\", e);\n    }\n  }\n  \n  private void startMLTraining()\n  {\n    SwipeMLTrainer trainer = new SwipeMLTrainer(this);\n    \n    if (!trainer.canTrain())\n    {\n      Toast.makeText(this, \"Not enough data for training. Need at least 100 samples.\", \n                     Toast.LENGTH_LONG).show();\n      return;\n    }\n    \n    // Create progress dialog\n    final ProgressDialog progressDialog = new ProgressDialog(this);\n    progressDialog.setTitle(\"Training ML Model\");\n    progressDialog.setMessage(\"Preparing training data...\");\n    progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n    progressDialog.setMax(100);\n    progressDialog.setCancelable(false);\n    progressDialog.show();\n    \n    // Set up training listener\n    trainer.setTrainingListener(new SwipeMLTrainer.TrainingListener()\n    {\n      @Override\n      public void onTrainingStarted()\n      {\n        runOnUiThread(() -> {\n          progressDialog.setMessage(\"Training in progress...\");\n        });\n      }\n      \n      @Override\n      public void onTrainingProgress(int progress, int total)\n      {\n        runOnUiThread(() -> {\n          progressDialog.setProgress(progress);\n        });\n      }\n      \n      @Override\n      public void onTrainingCompleted(SwipeMLTrainer.TrainingResult result)\n      {\n        runOnUiThread(() -> {\n          progressDialog.dismiss();\n          String message = String.format(\n            \"Training completed!\\nSamples: %d\\nTime: %.1f seconds\\nAccuracy: %.1f%%\",\n            result.samplesUsed, result.trainingTimeMs / 1000.0, result.accuracy * 100);\n          Toast.makeText(SettingsActivity.this, message, Toast.LENGTH_LONG).show();\n        });\n      }\n      \n      @Override\n      public void onTrainingError(String error)\n      {\n        runOnUiThread(() -> {\n          progressDialog.dismiss();\n          Toast.makeText(SettingsActivity.this, \"Training failed: \" + error, \n                         Toast.LENGTH_LONG).show();\n        });\n      }\n    });\n    \n    // Start training\n    trainer.startTraining();\n  }\n  \n  private Properties loadVersionInfo()\n  {\n    Properties props = new Properties();\n    try\n    {\n      BufferedReader reader = new BufferedReader(\n        new InputStreamReader(getResources().openRawResource(\n          getResources().getIdentifier(\"version_info\", \"raw\", getPackageName()))));\n      props.load(reader);\n      reader.close();\n    }\n    catch (Exception e)\n    {\n      android.util.Log.e(\"SettingsActivity\", \"Failed to load version info\", e);\n    }\n    return props;\n  }\n  \n  private static final int REQUEST_CODE_INSTALL_APK = 1005;\n\n  private void installUpdate()\n  {\n    // Try /storage/emulated/0/unexpected/ first\n    File unexpectedDir = new File(\"/storage/emulated/0/unexpected\");\n\n    if (!unexpectedDir.exists() || !unexpectedDir.isDirectory())\n    {\n      // Fallback: open file picker to let user choose APK\n      Toast.makeText(this, \"ğŸ“‚ Directory not found. Opening file picker...\", Toast.LENGTH_SHORT).show();\n      openApkFilePicker();\n      return;\n    }\n\n    // Get all APK files in the directory\n    File[] apkFiles = unexpectedDir.listFiles((dir, name) -> name.toLowerCase().endsWith(\".apk\"));\n\n    if (apkFiles == null || apkFiles.length == 0)\n    {\n      // Fallback: open file picker\n      Toast.makeText(this, \"ğŸ“‚ No APKs in /storage/emulated/0/unexpected/. Opening file picker...\", Toast.LENGTH_SHORT).show();\n      openApkFilePicker();\n      return;\n    }\n\n    // Sort by modification time (newest first)\n    java.util.Arrays.sort(apkFiles, (a, b) -> Long.compare(b.lastModified(), a.lastModified()));\n\n    // Create list of APK names with sizes and dates\n    final String[] apkNames = new String[apkFiles.length];\n    for (int i = 0; i < apkFiles.length; i++)\n    {\n      File apk = apkFiles[i];\n      long sizeMB = apk.length() / (1024 * 1024);\n      String date = new java.text.SimpleDateFormat(\"MM-dd HH:mm\", java.util.Locale.US)\n                        .format(new java.util.Date(apk.lastModified()));\n      apkNames[i] = String.format(\"%s\\n%d MB â€¢ %s\", apk.getName(), sizeMB, date);\n    }\n\n    final File[] finalApkFiles = apkFiles;\n\n    // Show selection dialog\n    android.app.AlertDialog.Builder builder = new android.app.AlertDialog.Builder(this);\n    builder.setTitle(\"ğŸ“¦ Select APK to Install\");\n    builder.setItems(apkNames, (dialog, which) -> {\n      File selectedApk = finalApkFiles[which];\n      installApkFile(selectedApk);\n    });\n    builder.setNegativeButton(\"Cancel\", null);\n    builder.show();\n  }\n\n  private void installApkFile(File apkFile)\n  {\n    try\n    {\n      // Check if we can request package installs\n      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)\n      {\n        if (!getPackageManager().canRequestPackageInstalls())\n        {\n          // Request permission to install packages\n          Intent intent = new Intent(android.provider.Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES);\n          intent.setData(Uri.parse(\"package:\" + getPackageName()));\n          Toast.makeText(this, \"âš ï¸ Please allow installing from this source\", Toast.LENGTH_LONG).show();\n          startActivity(intent);\n          return;\n        }\n      }\n\n      // Use ACTION_VIEW with file URI\n      Intent intent = new Intent(Intent.ACTION_VIEW);\n      Uri apkUri = Uri.fromFile(apkFile);\n\n      intent.setDataAndType(apkUri, \"application/vnd.android.package-archive\");\n      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\n      Log.d(\"SettingsActivity\", \"Installing APK: \" + apkFile.getAbsolutePath());\n      startActivity(intent);\n    }\n    catch (Exception e)\n    {\n      Log.e(\"SettingsActivity\", \"Failed to install APK\", e);\n\n      // If the above fails, show alternative options\n      showInstallAlternatives(apkFile, e);\n    }\n  }\n\n  private void installApkFromUri(Uri apkUri, String filename)\n  {\n    try\n    {\n      // Check if we can request package installs\n      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)\n      {\n        if (!getPackageManager().canRequestPackageInstalls())\n        {\n          // Request permission to install packages\n          Intent intent = new Intent(android.provider.Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES);\n          intent.setData(Uri.parse(\"package:\" + getPackageName()));\n          Toast.makeText(this, \"âš ï¸ Please allow installing from this source\", Toast.LENGTH_LONG).show();\n          startActivity(intent);\n          return;\n        }\n      }\n\n      // Use ACTION_VIEW with content URI\n      Intent intent = new Intent(Intent.ACTION_VIEW);\n      intent.setDataAndType(apkUri, \"application/vnd.android.package-archive\");\n      intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_GRANT_READ_URI_PERMISSION);\n\n      Log.d(\"SettingsActivity\", \"Installing APK from URI: \" + filename);\n      startActivity(intent);\n    }\n    catch (Exception e)\n    {\n      Log.e(\"SettingsActivity\", \"Failed to install APK from URI\", e);\n      Toast.makeText(this, \"âŒ Install failed: \" + e.getMessage(), Toast.LENGTH_LONG).show();\n    }\n  }\n\n  private void showInstallAlternatives(File apkFile, Exception error)\n  {\n    android.app.AlertDialog.Builder builder = new android.app.AlertDialog.Builder(this);\n    builder.setTitle(\"âš ï¸ Installation Failed\");\n    builder.setMessage(\"Could not open installer:\\n\" + error.getMessage() + \"\\n\\nChoose an alternative:\");\n\n    // Option 1: Use file picker to select and install\n    builder.setPositiveButton(\"ğŸ“‚ Open with File Manager\", (dialog, which) -> {\n      try\n      {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setDataAndType(Uri.fromFile(apkFile.getParentFile()), \"resource/folder\");\n        startActivity(intent);\n      }\n      catch (Exception e2)\n      {\n        Toast.makeText(this, \"Could not open file manager: \" + e2.getMessage(), Toast.LENGTH_LONG).show();\n      }\n    });\n\n    // Option 2: Copy path to clipboard\n    builder.setNeutralButton(\"ğŸ“‹ Copy Path\", (dialog, which) -> {\n      android.content.ClipboardManager clipboard =\n        (android.content.ClipboardManager) getSystemService(android.content.Context.CLIPBOARD_SERVICE);\n      android.content.ClipData clip = android.content.ClipData.newPlainText(\"APK Path\", apkFile.getAbsolutePath());\n      clipboard.setPrimaryClip(clip);\n      Toast.makeText(this, \"âœ… Path copied: \" + apkFile.getAbsolutePath(), Toast.LENGTH_LONG).show();\n    });\n\n    builder.setNegativeButton(\"Cancel\", null);\n    builder.show();\n  }\n  \n  void fallbackEncrypted()\n  {\n    // Can't communicate with the user here.\n    finish();\n  }\n\n  protected void onStop()\n  {\n    DirectBootAwarePreferences\n      .copy_preferences_to_protected_storage(this,\n          getPreferenceManager().getSharedPreferences());\n    super.onStop();\n  }\n  \n  /**\n   * Setup backup/restore preference handlers\n   */\n  private void setupBackupRestoreHandlers()\n  {\n    // Backup configuration\n    Preference backupPref = findPreference(\"backup_config\");\n    if (backupPref != null)\n    {\n      backupPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          startBackup();\n          return true;\n        }\n      });\n    }\n\n    // Restore configuration\n    Preference restorePref = findPreference(\"restore_config\");\n    if (restorePref != null)\n    {\n      restorePref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          startRestore();\n          return true;\n        }\n      });\n    }\n\n    // Export custom dictionary\n    Preference exportCustomDictPref = findPreference(\"export_custom_dictionary\");\n    if (exportCustomDictPref != null)\n    {\n      exportCustomDictPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          startExportCustomDictionary();\n          return true;\n        }\n      });\n    }\n\n    // Import custom dictionary\n    Preference importCustomDictPref = findPreference(\"import_custom_dictionary\");\n    if (importCustomDictPref != null)\n    {\n      importCustomDictPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          startImportCustomDictionary();\n          return true;\n        }\n      });\n    }\n\n    // Export clipboard history\n    Preference exportClipboardPref = findPreference(\"export_clipboard_history\");\n    if (exportClipboardPref != null)\n    {\n      exportClipboardPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          startExportClipboardHistory();\n          return true;\n        }\n      });\n    }\n\n    // Import clipboard history\n    Preference importClipboardPref = findPreference(\"import_clipboard_history\");\n    if (importClipboardPref != null)\n    {\n      importClipboardPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          startImportClipboardHistory();\n          return true;\n        }\n      });\n    }\n  }\n\n  /**\n   * Start backup process using Storage Access Framework\n   */\n  private void startBackup()\n  {\n    // Create filename with timestamp\n    String timestamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\", Locale.US).format(new Date());\n    String fileName = \"kb-config-\" + timestamp + \".json\";\n\n    // Use Storage Access Framework to let user choose location\n    Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);\n    intent.addCategory(Intent.CATEGORY_OPENABLE);\n    intent.setType(\"application/json\");\n    intent.putExtra(Intent.EXTRA_TITLE, fileName);\n\n    try\n    {\n      startActivityForResult(intent, REQUEST_CODE_BACKUP);\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Failed to open file picker: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Failed to start backup\", e);\n    }\n  }\n\n  /**\n   * Start restore process using Storage Access Framework\n   */\n  private void startRestore()\n  {\n    // Use Storage Access Framework to let user choose file\n    Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n    intent.addCategory(Intent.CATEGORY_OPENABLE);\n    intent.setType(\"application/json\");\n\n    try\n    {\n      startActivityForResult(intent, REQUEST_CODE_RESTORE);\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Failed to open file picker: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Failed to start restore\", e);\n    }\n  }\n\n  /**\n   * Open file picker for ONNX model selection\n   */\n  private void openFilePicker(int requestCode)\n  {\n    Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n    intent.addCategory(Intent.CATEGORY_OPENABLE);\n    intent.setType(\"*/*\"); // ONNX files might not have MIME type registered\n\n    try\n    {\n      startActivityForResult(intent, requestCode);\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Failed to open file picker: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Failed to start file picker\", e);\n    }\n  }\n\n  @Override\n  protected void onActivityResult(int requestCode, int resultCode, Intent data)\n  {\n    super.onActivityResult(requestCode, resultCode, data);\n\n    if (resultCode != RESULT_OK || data == null)\n    {\n      return;\n    }\n\n    Uri uri = data.getData();\n    if (uri == null)\n    {\n      return;\n    }\n\n    if (requestCode == REQUEST_CODE_BACKUP)\n    {\n      performBackup(uri);\n    }\n    else if (requestCode == REQUEST_CODE_RESTORE)\n    {\n      performRestore(uri);\n    }\n    else if (requestCode == REQUEST_CODE_EXPORT_CUSTOM_DICT)\n    {\n      performExportCustomDictionary(uri);\n    }\n    else if (requestCode == REQUEST_CODE_IMPORT_CUSTOM_DICT)\n    {\n      performImportCustomDictionary(uri);\n    }\n    else if (requestCode == REQUEST_CODE_EXPORT_CLIPBOARD)\n    {\n      performExportClipboardHistory(uri);\n    }\n    else if (requestCode == REQUEST_CODE_IMPORT_CLIPBOARD)\n    {\n      performImportClipboardHistory(uri);\n    }\n    else if (requestCode == REQUEST_CODE_NEURAL_ENCODER)\n    {\n      handleNeuralModelFile(uri, true);\n    }\n    else if (requestCode == REQUEST_CODE_NEURAL_DECODER)\n    {\n      handleNeuralModelFile(uri, false);\n    }\n    else if (requestCode == REQUEST_CODE_INSTALL_APK)\n    {\n      handleApkFileSelection(uri);\n    }\n  }\n\n  private void openApkFilePicker()\n  {\n    Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n    intent.addCategory(Intent.CATEGORY_OPENABLE);\n    intent.setType(\"application/vnd.android.package-archive\");\n\n    try\n    {\n      startActivityForResult(intent, REQUEST_CODE_INSTALL_APK);\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Failed to open file picker: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Failed to start APK file picker\", e);\n    }\n  }\n\n  private void handleApkFileSelection(Uri uri)\n  {\n    try\n    {\n      // Get filename\n      String filename = null;\n      try (android.database.Cursor cursor = getContentResolver().query(uri, null, null, null, null))\n      {\n        if (cursor != null && cursor.moveToFirst())\n        {\n          int nameIndex = cursor.getColumnIndex(android.provider.OpenableColumns.DISPLAY_NAME);\n          if (nameIndex >= 0)\n          {\n            filename = cursor.getString(nameIndex);\n          }\n        }\n      }\n\n      if (filename == null)\n      {\n        filename = uri.getLastPathSegment();\n      }\n\n      // Validate it's an APK\n      if (filename != null && !filename.toLowerCase().endsWith(\".apk\"))\n      {\n        Toast.makeText(this, \"âŒ File must be an .apk file\", Toast.LENGTH_SHORT).show();\n        return;\n      }\n\n      // Install directly from content URI\n      installApkFromUri(uri, filename);\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Error selecting APK: \" + e.getMessage(), Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Error handling APK file selection\", e);\n    }\n  }\n\n  private void handleNeuralModelFile(Uri uri, boolean isEncoder)\n  {\n    try\n    {\n      // Take persistent permission to access the file\n      final int takeFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION;\n      getContentResolver().takePersistableUriPermission(uri, takeFlags);\n\n      // Validate file can be accessed via ContentResolver\n      long fileSize = 0;\n      try (java.io.InputStream inputStream = getContentResolver().openInputStream(uri))\n      {\n        if (inputStream == null)\n        {\n          Toast.makeText(this, \"Cannot access file\", Toast.LENGTH_LONG).show();\n          return;\n        }\n\n        // Read a few bytes to verify it's accessible\n        byte[] header = new byte[4];\n        int bytesRead = inputStream.read(header);\n        if (bytesRead < 4)\n        {\n          Toast.makeText(this, \"File is empty or unreadable\", Toast.LENGTH_LONG).show();\n          return;\n        }\n\n        // Get file size for display\n        fileSize = inputStream.available() + bytesRead;\n      }\n\n      // Get filename from URI\n      String filename = null;\n      try (android.database.Cursor cursor = getContentResolver().query(uri, null, null, null, null))\n      {\n        if (cursor != null && cursor.moveToFirst())\n        {\n          int nameIndex = cursor.getColumnIndex(android.provider.OpenableColumns.DISPLAY_NAME);\n          if (nameIndex >= 0)\n          {\n            filename = cursor.getString(nameIndex);\n          }\n\n          // Get accurate file size\n          int sizeIndex = cursor.getColumnIndex(android.provider.OpenableColumns.SIZE);\n          if (sizeIndex >= 0)\n          {\n            fileSize = cursor.getLong(sizeIndex);\n          }\n        }\n      }\n\n      if (filename == null)\n      {\n        filename = uri.getLastPathSegment();\n      }\n\n      // Validate it's an ONNX file\n      if (filename != null && !filename.toLowerCase().endsWith(\".onnx\"))\n      {\n        Toast.makeText(this, \"File must be an .onnx file\", Toast.LENGTH_SHORT).show();\n        return;\n      }\n\n      // Save content URI to preferences (not file path!)\n      SharedPreferences.Editor editor = getPreferenceManager().getSharedPreferences().edit();\n      String prefKey = isEncoder ? \"neural_custom_encoder_uri\" : \"neural_custom_decoder_uri\";\n      editor.putString(prefKey, uri.toString());\n      editor.apply();\n\n      // Format file size\n      String sizeStr = formatFileSize(fileSize);\n\n      // Update preference summary immediately\n      String prefItemKey = isEncoder ? \"neural_load_encoder\" : \"neural_load_decoder\";\n      Preference pref = findPreference(prefItemKey);\n      if (pref != null)\n      {\n        pref.setSummary(\"âœ… \" + filename + \" (\" + sizeStr + \")\");\n      }\n\n      Toast.makeText(this, \"âœ… \" + (isEncoder ? \"Encoder\" : \"Decoder\") + \" file selected: \" + filename + \" (\" + sizeStr + \")\", Toast.LENGTH_LONG).show();\n\n      // Check if both files are now set and prompt user to change model version if needed\n      SharedPreferences prefs = getPreferenceManager().getSharedPreferences();\n      String encoderUri = prefs.getString(\"neural_custom_encoder_uri\", null);\n      String decoderUri = prefs.getString(\"neural_custom_decoder_uri\", null);\n      String modelVersion = prefs.getString(\"neural_model_version\", \"v2\");\n\n      if (encoderUri != null && decoderUri != null)\n      {\n        if (!modelVersion.equals(\"custom\"))\n        {\n          Toast.makeText(this, \"ğŸ“ Both files loaded! Change 'Model Version' to 'custom' to use them.\", Toast.LENGTH_LONG).show();\n        }\n        else\n        {\n          Toast.makeText(this, \"ğŸ”„ Custom models will load on next swipe. This may take a moment...\", Toast.LENGTH_LONG).show();\n        }\n      }\n\n      // Update model info\n      updateNeuralModelInfo();\n    }\n    catch (SecurityException e)\n    {\n      Toast.makeText(this, \"âŒ Permission denied. Please grant access to the file.\", Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Security exception loading model\", e);\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Error loading model: \" + e.getMessage(), Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Error loading neural model file\", e);\n    }\n  }\n\n  /**\n   * Perform backup to the selected URI\n   */\n  private void performBackup(Uri uri)\n  {\n    try\n    {\n      SharedPreferences prefs = getPreferenceManager().getSharedPreferences();\n      boolean success = backupRestoreManager.exportConfig(uri, prefs);\n\n      if (success)\n      {\n        int count = prefs.getAll().size();\n        Toast.makeText(this, \"Successfully exported \" + count + \" settings\",\n                       Toast.LENGTH_LONG).show();\n      }\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Backup failed: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Backup failed\", e);\n    }\n  }\n\n  /**\n   * Perform restore from the selected URI\n   */\n  private void performRestore(Uri uri)\n  {\n    try\n    {\n      SharedPreferences prefs = getPreferenceManager().getSharedPreferences();\n      BackupRestoreManager.ImportResult result =\n        backupRestoreManager.importConfig(uri, prefs);\n\n      // Show results and warnings\n      showRestoreResults(result);\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Restore failed: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Restore failed\", e);\n    }\n  }\n\n  /**\n   * Start export custom dictionary process using Storage Access Framework\n   */\n  private void startExportCustomDictionary()\n  {\n    // Create filename with timestamp\n    String timestamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\", Locale.US).format(new Date());\n    String fileName = \"custom-dictionary-\" + timestamp + \".json\";\n\n    // Use Storage Access Framework to let user choose location\n    Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);\n    intent.addCategory(Intent.CATEGORY_OPENABLE);\n    intent.setType(\"application/json\");\n    intent.putExtra(Intent.EXTRA_TITLE, fileName);\n\n    try\n    {\n      startActivityForResult(intent, REQUEST_CODE_EXPORT_CUSTOM_DICT);\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Failed to open file picker: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Failed to start custom dictionary export\", e);\n    }\n  }\n\n  /**\n   * Perform custom dictionary export to the selected URI\n   */\n  private void performExportCustomDictionary(Uri uri)\n  {\n    try\n    {\n      // Use DirectBootAwarePreferences (same as DictionaryDataSource)\n      SharedPreferences prefs = DirectBootAwarePreferences.get_shared_preferences(this);\n\n      // Get custom words\n      String customWordsJson = prefs.getString(\"custom_words\", \"{}\");\n      org.json.JSONObject customWords = new org.json.JSONObject(customWordsJson);\n      int customWordCount = customWords.length();\n\n      // Get disabled words\n      java.util.Set<String> disabledWordsSet = prefs.getStringSet(\"disabled_words\", new java.util.HashSet<>());\n      org.json.JSONArray disabledWords = new org.json.JSONArray(disabledWordsSet);\n      int disabledWordCount = disabledWordsSet.size();\n\n      if (customWordCount == 0 && disabledWordCount == 0)\n      {\n        Toast.makeText(this, \"No custom or disabled words to export\", Toast.LENGTH_SHORT).show();\n        return;\n      }\n\n      // Create combined export format\n      org.json.JSONObject exportData = new org.json.JSONObject();\n      exportData.put(\"custom_words\", customWords);\n      exportData.put(\"disabled_words\", disabledWords);\n      exportData.put(\"export_version\", 1);\n      exportData.put(\"export_date\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.US).format(new Date()));\n\n      // Write to file using ContentResolver\n      try (java.io.OutputStream outputStream = getContentResolver().openOutputStream(uri))\n      {\n        if (outputStream == null)\n        {\n          throw new java.io.IOException(\"Failed to open output stream\");\n        }\n\n        // Write formatted JSON\n        String prettyJson = exportData.toString(2); // Indent with 2 spaces\n        outputStream.write(prettyJson.getBytes());\n      }\n\n      // Show success message\n      String message = \"Successfully exported:\\n\" +\n                      \"â€¢ \" + customWordCount + \" custom word\" + (customWordCount == 1 ? \"\" : \"s\") + \"\\n\" +\n                      \"â€¢ \" + disabledWordCount + \" disabled word\" + (disabledWordCount == 1 ? \"\" : \"s\");\n      Toast.makeText(this, message, Toast.LENGTH_LONG).show();\n      Log.d(\"SettingsActivity\", \"Exported \" + customWordCount + \" custom words and \" +\n            disabledWordCount + \" disabled words\");\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Export failed: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Custom dictionary export failed\", e);\n    }\n  }\n\n  /**\n   * Start import custom dictionary process using Storage Access Framework\n   */\n  private void startImportCustomDictionary()\n  {\n    // Use Storage Access Framework to let user choose file\n    Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n    intent.addCategory(Intent.CATEGORY_OPENABLE);\n    intent.setType(\"application/json\");\n\n    try\n    {\n      startActivityForResult(intent, REQUEST_CODE_IMPORT_CUSTOM_DICT);\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Failed to open file picker: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Failed to start custom dictionary import\", e);\n    }\n  }\n\n  /**\n   * Perform custom dictionary import from the selected URI\n   */\n  private void performImportCustomDictionary(Uri uri)\n  {\n    try\n    {\n      // Read file content\n      StringBuilder jsonContent = new StringBuilder();\n      try (java.io.InputStream inputStream = getContentResolver().openInputStream(uri))\n      {\n        if (inputStream == null)\n        {\n          throw new java.io.IOException(\"Failed to open input stream\");\n        }\n\n        java.io.BufferedReader reader = new java.io.BufferedReader(\n          new java.io.InputStreamReader(inputStream));\n        String line;\n        while ((line = reader.readLine()) != null)\n        {\n          jsonContent.append(line);\n        }\n      }\n\n      // Parse JSON\n      org.json.JSONObject importData = new org.json.JSONObject(jsonContent.toString());\n\n      // Use DirectBootAwarePreferences (same as DictionaryDataSource)\n      SharedPreferences prefs = DirectBootAwarePreferences.get_shared_preferences(this);\n      SharedPreferences.Editor editor = prefs.edit();\n\n      // Import custom words (merge without duplicates, keep higher frequency)\n      int customWordsAdded = 0;\n      int customWordsUpdated = 0;\n      if (importData.has(\"custom_words\"))\n      {\n        org.json.JSONObject importCustomWords = importData.getJSONObject(\"custom_words\");\n\n        // Get existing custom words\n        String existingJson = prefs.getString(\"custom_words\", \"{}\");\n        org.json.JSONObject existingCustomWords = new org.json.JSONObject(existingJson);\n\n        // Merge: add new words, update if imported frequency is higher\n        java.util.Iterator<String> keys = importCustomWords.keys();\n        while (keys.hasNext())\n        {\n          String word = keys.next();\n          int importedFreq = importCustomWords.getInt(word);\n\n          if (existingCustomWords.has(word))\n          {\n            int existingFreq = existingCustomWords.getInt(word);\n            if (importedFreq > existingFreq)\n            {\n              existingCustomWords.put(word, importedFreq);\n              customWordsUpdated++;\n            }\n            // If existing freq is higher or equal, keep existing\n          }\n          else\n          {\n            existingCustomWords.put(word, importedFreq);\n            customWordsAdded++;\n          }\n        }\n\n        // Save merged custom words\n        editor.putString(\"custom_words\", existingCustomWords.toString());\n      }\n\n      // Import disabled words (merge without duplicates)\n      int disabledWordsAdded = 0;\n      if (importData.has(\"disabled_words\"))\n      {\n        org.json.JSONArray importDisabledWords = importData.getJSONArray(\"disabled_words\");\n\n        // Get existing disabled words\n        java.util.Set<String> existingDisabled = new java.util.HashSet<>(\n          prefs.getStringSet(\"disabled_words\", new java.util.HashSet<>()));\n        int initialSize = existingDisabled.size();\n\n        // Add imported words (Set automatically handles duplicates)\n        for (int i = 0; i < importDisabledWords.length(); i++)\n        {\n          existingDisabled.add(importDisabledWords.getString(i));\n        }\n\n        disabledWordsAdded = existingDisabled.size() - initialSize;\n\n        // Save merged disabled words\n        editor.putStringSet(\"disabled_words\", existingDisabled);\n      }\n\n      editor.apply();\n\n      // Show results\n      StringBuilder message = new StringBuilder(\"Import complete:\\n\");\n      if (customWordsAdded > 0 || customWordsUpdated > 0)\n      {\n        message.append(\"â€¢ Custom words: \")\n               .append(customWordsAdded).append(\" added\");\n        if (customWordsUpdated > 0)\n        {\n          message.append(\", \").append(customWordsUpdated).append(\" updated\");\n        }\n        message.append(\"\\n\");\n      }\n      if (disabledWordsAdded > 0)\n      {\n        message.append(\"â€¢ Disabled words: \").append(disabledWordsAdded).append(\" added\\n\");\n      }\n      if (customWordsAdded == 0 && customWordsUpdated == 0 && disabledWordsAdded == 0)\n      {\n        message.append(\"â€¢ No new words (all already exist)\");\n      }\n\n      Toast.makeText(this, message.toString(), Toast.LENGTH_LONG).show();\n      Log.d(\"SettingsActivity\", \"Imported: \" + customWordsAdded + \" custom words added, \" +\n            customWordsUpdated + \" updated, \" + disabledWordsAdded + \" disabled words added\");\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Import failed: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Custom dictionary import failed\", e);\n    }\n  }\n\n  /**\n   * Start export clipboard history process using Storage Access Framework\n   */\n  private void startExportClipboardHistory()\n  {\n    // Create filename with timestamp\n    String timestamp = new SimpleDateFormat(\"yyyyMMdd_HHmmss\", Locale.US).format(new Date());\n    String fileName = \"clipboard-history-\" + timestamp + \".json\";\n\n    // Use Storage Access Framework to let user choose location\n    Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);\n    intent.addCategory(Intent.CATEGORY_OPENABLE);\n    intent.setType(\"application/json\");\n    intent.putExtra(Intent.EXTRA_TITLE, fileName);\n\n    try\n    {\n      startActivityForResult(intent, REQUEST_CODE_EXPORT_CLIPBOARD);\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Failed to open file picker: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Failed to start clipboard export\", e);\n    }\n  }\n\n  /**\n   * Perform clipboard history export to the selected URI\n   */\n  private void performExportClipboardHistory(Uri uri)\n  {\n    try\n    {\n      ClipboardDatabase db = ClipboardDatabase.getInstance(this);\n      org.json.JSONObject exportData = db.exportToJSON();\n\n      if (exportData == null)\n      {\n        Toast.makeText(this, \"Failed to export clipboard history\", Toast.LENGTH_SHORT).show();\n        return;\n      }\n\n      int activeCount = exportData.getInt(\"total_active\");\n      int pinnedCount = exportData.getInt(\"total_pinned\");\n\n      if (activeCount == 0 && pinnedCount == 0)\n      {\n        Toast.makeText(this, \"No clipboard entries to export\", Toast.LENGTH_SHORT).show();\n        return;\n      }\n\n      // Write to file using ContentResolver\n      try (java.io.OutputStream outputStream = getContentResolver().openOutputStream(uri))\n      {\n        if (outputStream == null)\n        {\n          throw new java.io.IOException(\"Failed to open output stream\");\n        }\n\n        // Write formatted JSON\n        String prettyJson = exportData.toString(2); // Indent with 2 spaces\n        outputStream.write(prettyJson.getBytes());\n      }\n\n      // Show success message\n      String message = \"Successfully exported:\\n\" +\n                      \"â€¢ \" + activeCount + \" active entr\" + (activeCount == 1 ? \"y\" : \"ies\") + \"\\n\" +\n                      \"â€¢ \" + pinnedCount + \" pinned entr\" + (pinnedCount == 1 ? \"y\" : \"ies\");\n      Toast.makeText(this, message, Toast.LENGTH_LONG).show();\n      Log.d(\"SettingsActivity\", \"Exported \" + activeCount + \" active and \" +\n            pinnedCount + \" pinned clipboard entries\");\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Export failed: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Clipboard export failed\", e);\n    }\n  }\n\n  /**\n   * Start import clipboard history process using Storage Access Framework\n   */\n  private void startImportClipboardHistory()\n  {\n    // Use Storage Access Framework to let user choose file\n    Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);\n    intent.addCategory(Intent.CATEGORY_OPENABLE);\n    intent.setType(\"application/json\");\n\n    try\n    {\n      startActivityForResult(intent, REQUEST_CODE_IMPORT_CLIPBOARD);\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Failed to open file picker: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Failed to start clipboard import\", e);\n    }\n  }\n\n  /**\n   * Perform clipboard history import from the selected URI\n   */\n  private void performImportClipboardHistory(Uri uri)\n  {\n    try\n    {\n      // Read file content\n      StringBuilder jsonContent = new StringBuilder();\n      try (java.io.InputStream inputStream = getContentResolver().openInputStream(uri))\n      {\n        if (inputStream == null)\n        {\n          throw new java.io.IOException(\"Failed to open input stream\");\n        }\n\n        java.io.BufferedReader reader = new java.io.BufferedReader(\n          new java.io.InputStreamReader(inputStream));\n        String line;\n        while ((line = reader.readLine()) != null)\n        {\n          jsonContent.append(line);\n        }\n      }\n\n      // Parse JSON\n      org.json.JSONObject importData = new org.json.JSONObject(jsonContent.toString());\n\n      // Import using ClipboardDatabase\n      ClipboardDatabase db = ClipboardDatabase.getInstance(this);\n      int[] results = db.importFromJSON(importData);\n\n      int activeAdded = results[0];\n      int pinnedAdded = results[1];\n      int duplicatesSkipped = results[2];\n\n      // Show results\n      StringBuilder message = new StringBuilder(\"Import complete:\\n\");\n      if (activeAdded > 0)\n      {\n        message.append(\"â€¢ \").append(activeAdded).append(\" active entr\")\n               .append(activeAdded == 1 ? \"y\" : \"ies\").append(\" added\\n\");\n      }\n      if (pinnedAdded > 0)\n      {\n        message.append(\"â€¢ \").append(pinnedAdded).append(\" pinned entr\")\n               .append(pinnedAdded == 1 ? \"y\" : \"ies\").append(\" added\\n\");\n      }\n      if (duplicatesSkipped > 0)\n      {\n        message.append(\"â€¢ \").append(duplicatesSkipped).append(\" duplicate\")\n               .append(duplicatesSkipped == 1 ? \"\" : \"s\").append(\" skipped\\n\");\n      }\n      if (activeAdded == 0 && pinnedAdded == 0)\n      {\n        message.append(\"â€¢ No new entries (all already exist)\");\n      }\n\n      Toast.makeText(this, message.toString(), Toast.LENGTH_LONG).show();\n      Log.d(\"SettingsActivity\", \"Imported: \" + activeAdded + \" active, \" +\n            pinnedAdded + \" pinned, \" + duplicatesSkipped + \" duplicates skipped\");\n    }\n    catch (Exception e)\n    {\n      Toast.makeText(this, \"Import failed: \" + e.getMessage(),\n                     Toast.LENGTH_LONG).show();\n      Log.e(\"SettingsActivity\", \"Clipboard import failed\", e);\n    }\n  }\n\n  /**\n   * Show restore results with warnings and restart prompt\n   */\n  private void showRestoreResults(BackupRestoreManager.ImportResult result)\n  {\n    StringBuilder message = new StringBuilder();\n    message.append(\"Successfully restored \").append(result.importedCount).append(\" settings\");\n\n    if (result.skippedCount > 0)\n    {\n      message.append(\"\\n\\nSkipped \").append(result.skippedCount)\n             .append(\" invalid or unrecognized settings\");\n    }\n\n    // Warn about complex preferences that weren't restored\n    boolean skippedLayouts = result.skippedKeys.contains(\"layouts\");\n    boolean skippedExtraKeys = result.skippedKeys.contains(\"extra_keys\") ||\n                               result.skippedKeys.contains(\"custom_extra_keys\");\n\n    if (skippedLayouts || skippedExtraKeys)\n    {\n      message.append(\"\\n\\nâš ï¸ Not restored:\");\n      if (skippedLayouts)\n      {\n        message.append(\"\\n  â€¢ Keyboard layouts (needs manual reconfiguration)\");\n      }\n      if (skippedExtraKeys)\n      {\n        message.append(\"\\n  â€¢ Custom extra keys (needs manual reconfiguration)\");\n      }\n    }\n\n    if (!result.sourceVersion.equals(\"unknown\"))\n    {\n      message.append(\"\\n\\nSource version: \").append(result.sourceVersion);\n    }\n\n    if (result.hasScreenSizeMismatch())\n    {\n      message.append(\"\\n\\nâš ï¸ Warning: Backup was from a device with different screen size. \")\n             .append(\"Layout settings may need adjustment.\");\n    }\n\n    message.append(\"\\n\\nThe app needs to restart to apply all settings correctly.\");\n\n    // Create dialog with restart option\n    android.app.AlertDialog.Builder builder = new android.app.AlertDialog.Builder(this);\n    builder.setTitle(\"Restore Complete\");\n    builder.setMessage(message.toString());\n    builder.setCancelable(false);\n\n    builder.setPositiveButton(\"Restart Now\", (dialog, which) -> {\n      // Restart the app\n      Intent intent = getBaseContext().getPackageManager()\n        .getLaunchIntentForPackage(getBaseContext().getPackageName());\n      if (intent != null)\n      {\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);\n        startActivity(intent);\n      }\n      finish();\n      System.exit(0);\n    });\n\n    builder.setNegativeButton(\"Later\", (dialog, which) -> {\n      Toast.makeText(this, \"Restart the app to apply all settings\",\n                     Toast.LENGTH_LONG).show();\n    });\n\n    builder.show();\n  }\n\n  /**\n   * Setup CGR reset button functionality\n   */\n  private void setupCGRResetButtons()\n  {\n    // Reset to Optimal Values button\n    Preference resetOptimalPref = findPreference(\"swipe_reset_optimal\");\n    if (resetOptimalPref != null)\n    {\n      resetOptimalPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          resetToSwipeOptimal();\n          return true;\n        }\n      });\n    }\n\n    // Reset to Strict Values button\n    Preference resetStrictPref = findPreference(\"swipe_reset_strict\");\n    if (resetStrictPref != null)\n    {\n      resetStrictPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          resetToSwipeStrict();\n          return true;\n        }\n      });\n    }\n\n    // v1.33.8: Reset swipe corrections to defaults button\n    Preference resetCorrectionsRef = findPreference(\"reset_swipe_corrections\");\n    if (resetCorrectionsRef != null)\n    {\n      resetCorrectionsRef.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener()\n      {\n        @Override\n        public boolean onPreferenceClick(Preference preference)\n        {\n          resetSwipeCorrections();\n          return true;\n        }\n      });\n    }\n  }\n  \n  /**\n   * Reset to balanced keyboard swipe recognition values\n   */\n  private void resetToSwipeOptimal()\n  {\n    SharedPreferences prefs = getPreferenceManager().getSharedPreferences();\n    SharedPreferences.Editor editor = prefs.edit();\n    \n    // Set balanced values for keyboard gesture recognition\n    editor.putInt(\"proximity_weight\", 100);      // Balanced proximity requirement\n    editor.putInt(\"missing_key_penalty\", 1000);  // Strong penalty for missing letters (10.0)\n    editor.putInt(\"extra_key_penalty\", 200);     // Moderate penalty for extra letters (2.0)\n    editor.putInt(\"order_penalty\", 500);         // Moderate order enforcement (5.0)\n    editor.putInt(\"start_point_weight\", 300);    // Strong start emphasis (3.0)\n    editor.putInt(\"key_zone_radius\", 120);       // Large detection area\n    editor.putInt(\"path_sample_distance\", 10);   // Frequent sampling\n    editor.apply();\n    \n    // Force UI refresh\n    recreate();\n    \n    Toast.makeText(this, \"Reset to optimal keyboard recognition values\", Toast.LENGTH_SHORT).show();\n  }\n  \n  /**\n   * Reset to strict keyboard swipe recognition values\n   */\n  private void resetToSwipeStrict()\n  {\n    SharedPreferences prefs = getPreferenceManager().getSharedPreferences();\n    SharedPreferences.Editor editor = prefs.edit();\n\n    // Set strict values for precise recognition\n    editor.putInt(\"proximity_weight\", 200);      // High proximity requirement\n    editor.putInt(\"missing_key_penalty\", 1500);  // Very strong penalty for missing letters (15.0)\n    editor.putInt(\"extra_key_penalty\", 500);     // Higher penalty for extra letters (5.0)\n    editor.putInt(\"order_penalty\", 1000);        // Strict order enforcement (10.0)\n    editor.putInt(\"start_point_weight\", 500);    // Very strong start emphasis (5.0)\n    editor.putInt(\"key_zone_radius\", 80);        // Smaller detection area (precise)\n    editor.putInt(\"path_sample_distance\", 5);    // Very frequent sampling\n    editor.apply();\n\n    // Force UI refresh\n    recreate();\n\n    Toast.makeText(this, \"Reset to strict recognition values\", Toast.LENGTH_SHORT).show();\n  }\n\n  /**\n   * Reset swipe correction settings to defaults\n   * v1.33.8: Implements reset button for swipe corrections\n   */\n  private void resetSwipeCorrections()\n  {\n    SharedPreferences prefs = getPreferenceManager().getSharedPreferences();\n    SharedPreferences.Editor editor = prefs.edit();\n\n    // Reset to balanced preset\n    editor.putString(\"swipe_correction_preset\", \"balanced\");\n\n    // Reset fuzzy matching parameters to defaults\n    editor.putInt(\"autocorrect_max_length_diff\", 2);\n    editor.putInt(\"autocorrect_prefix_length\", 2);\n    editor.putInt(\"autocorrect_max_beam_candidates\", 3);\n    editor.putFloat(\"autocorrect_char_match_threshold\", 0.67f);\n    editor.putInt(\"autocorrect_confidence_min_frequency\", 500);\n\n    // Reset autocorrect toggles to defaults\n    editor.putBoolean(\"swipe_beam_autocorrect_enabled\", true);\n    editor.putBoolean(\"swipe_final_autocorrect_enabled\", true);\n    editor.putString(\"swipe_fuzzy_match_mode\", \"edit_distance\");\n\n    // Reset scoring weights to defaults\n    editor.putInt(\"swipe_prediction_source\", 60); // Balanced (60% NN, 40% freq)\n    editor.putFloat(\"swipe_common_words_boost\", 1.3f);\n    editor.putFloat(\"swipe_top5000_boost\", 1.0f);\n    editor.putFloat(\"swipe_rare_words_penalty\", 0.75f);\n\n    editor.apply();\n\n    // Force UI refresh to show updated values\n    recreate();\n\n    Toast.makeText(this, \"Reset all swipe correction settings to defaults\", Toast.LENGTH_LONG).show();\n    android.util.Log.d(\"SettingsActivity\", \"Reset swipe corrections to default values\");\n  }\n  \n  @Override\n  public void onSharedPreferenceChanged(SharedPreferences prefs, String key)\n  {\n    // v1.33.8: Handle swipe correction preset changes\n    if (\"swipe_correction_preset\".equals(key))\n    {\n      String preset = prefs.getString(key, \"balanced\");\n      applySwipeCorrectionPreset(prefs, preset);\n      Toast.makeText(this, \"Applied \\\"\" + preset + \"\\\" correction preset\", Toast.LENGTH_SHORT).show();\n      return;\n    }\n\n    // Trigger CGR parameter reload when settings change\n    if (key != null && key.startsWith(\"cgr_\"))\n    {\n      android.util.Log.d(\"SettingsActivity\", \"CGR parameter changed: \" + key);\n\n      // Parameter changes will take effect on next keyboard restart\n      android.util.Log.d(\"SettingsActivity\", \"CGR parameter \" + key + \" changed, will take effect on restart\");\n\n      // Show current value for verification and update summaries\n      int currentValue = prefs.getInt(key, -1);\n      Toast.makeText(this, \"Updated \" + key + \" = \" + currentValue + \" (takes effect immediately)\", Toast.LENGTH_LONG).show();\n\n      // Update parameter summaries to show new values\n      updateCGRParameterSummaries();\n    }\n\n    // No super call needed for interface method\n  }\n\n  /**\n   * Apply swipe correction preset values to fuzzy matching parameters\n   * v1.33.8: Implements the swipe_correction_preset functionality\n   *\n   * @param prefs SharedPreferences to update\n   * @param preset \"strict\", \"balanced\", or \"lenient\"\n   */\n  private void applySwipeCorrectionPreset(SharedPreferences prefs, String preset)\n  {\n    SharedPreferences.Editor editor = prefs.edit();\n\n    switch (preset)\n    {\n      case \"strict\":\n        // Strict (High Accuracy) - Minimize false corrections\n        editor.putInt(\"autocorrect_max_length_diff\", 1);       // Very strict on length\n        editor.putInt(\"autocorrect_prefix_length\", 3);         // First 3 letters must match\n        editor.putInt(\"autocorrect_max_beam_candidates\", 2);   // Only check top 2\n        editor.putFloat(\"autocorrect_char_match_threshold\", 0.80f); // 80% chars must match\n        android.util.Log.d(\"SettingsActivity\", \"Applied STRICT preset: length_diff=1, prefix=3, candidates=2, threshold=0.80\");\n        break;\n\n      case \"lenient\":\n        // Lenient (Flexible) - Maximize corrections, accept more false positives\n        editor.putInt(\"autocorrect_max_length_diff\", 4);       // Very forgiving\n        editor.putInt(\"autocorrect_prefix_length\", 1);         // Only first letter\n        editor.putInt(\"autocorrect_max_beam_candidates\", 5);   // Check more\n        editor.putFloat(\"autocorrect_char_match_threshold\", 0.55f); // Only 55% match needed\n        android.util.Log.d(\"SettingsActivity\", \"Applied LENIENT preset: length_diff=4, prefix=1, candidates=5, threshold=0.55\");\n        break;\n\n      case \"balanced\":\n      default:\n        // Balanced (Default) - Middle ground\n        editor.putInt(\"autocorrect_max_length_diff\", 2);       // Default\n        editor.putInt(\"autocorrect_prefix_length\", 2);         // Default\n        editor.putInt(\"autocorrect_max_beam_candidates\", 3);   // Default\n        editor.putFloat(\"autocorrect_char_match_threshold\", 0.67f); // Default\n        android.util.Log.d(\"SettingsActivity\", \"Applied BALANCED preset: length_diff=2, prefix=2, candidates=3, threshold=0.67\");\n        break;\n    }\n\n    editor.apply();\n  }\n  \n  @Override\n  protected void onResume()\n  {\n    super.onResume();\n    // Register for preference changes and update summaries\n    getPreferenceManager().getSharedPreferences().registerOnSharedPreferenceChangeListener(this);\n    updateCGRParameterSummaries();\n    updateClipboardStats();\n  }\n  \n  @Override\n  protected void onPause()\n  {\n    super.onPause();\n    // Unregister to prevent memory leaks\n    getPreferenceManager().getSharedPreferences().unregisterOnSharedPreferenceChangeListener(this);\n  }\n  \n  /**\n   * Update CGR parameter summaries with current values\n   */\n  private void updateCGRParameterSummaries()\n  {\n    SharedPreferences prefs = getPreferenceManager().getSharedPreferences();\n    \n    // Update E_SIGMA summary\n    Preference eSigmaPref = findPreference(\"cgr_e_sigma_config\");\n    if (eSigmaPref != null)\n    {\n      int eSigma = prefs.getInt(\"cgr_e_sigma\", 120);\n      eSigmaPref.setSummary(\"Current: \" + eSigma + \" (Position tolerance)\");\n    }\n    \n    // Update BETA summary  \n    Preference betaPref = findPreference(\"cgr_beta_config\");\n    if (betaPref != null)\n    {\n      int beta = prefs.getInt(\"cgr_beta\", 400);\n      betaPref.setSummary(\"Current: \" + beta + \" (Variance ratio)\");\n    }\n    \n    // Update LAMBDA summary\n    Preference lambdaPref = findPreference(\"cgr_lambda_config\");\n    if (lambdaPref != null)\n    {\n      int lambda = prefs.getInt(\"cgr_lambda\", 65);\n      lambdaPref.setSummary(\"Current: \" + lambda + \"% (Distance balance)\");\n    }\n    \n    // Update KAPPA summary\n    Preference kappaPref = findPreference(\"cgr_kappa_config\");\n    if (kappaPref != null)\n    {\n      int kappa = prefs.getInt(\"cgr_kappa\", 25);\n      kappaPref.setSummary(\"Current: \" + (kappa/10.0) + \" (End-point bias)\");\n    }\n    \n    // Update Length Filter summary\n    Preference lengthPref = findPreference(\"cgr_length_config\");\n    if (lengthPref != null)\n    {\n      int lengthFilter = prefs.getInt(\"cgr_length_filter\", 70);\n      lengthPref.setSummary(\"Current: \" + lengthFilter + \"% (Length similarity filter)\");\n    }\n  }\n\n  /**\n   * Update clipboard storage statistics preference with current data\n   */\n  private void updateClipboardStats()\n  {\n    Preference statsPref = findPreference(\"clipboard_storage_stats\");\n    if (statsPref != null)\n    {\n      try\n      {\n        ClipboardHistoryService service = ClipboardHistoryService.get_service(this);\n        if (service != null)\n        {\n          String stats = service.getStorageStats();\n          statsPref.setSummary(stats);\n        }\n        else\n        {\n          statsPref.setSummary(\"Clipboard service not available\");\n        }\n      }\n      catch (Exception e)\n      {\n        statsPref.setSummary(\"Error loading statistics\");\n        android.util.Log.e(\"SettingsActivity\", \"Failed to load clipboard stats\", e);\n      }\n    }\n  }\n\n  /**\n   * Update model file preference summary with currently selected file\n   */\n  private void updateModelFileSummary(Preference pref, String uriPrefKey)\n  {\n    try\n    {\n      SharedPreferences prefs = getPreferenceManager().getSharedPreferences();\n      String uriStr = prefs.getString(uriPrefKey, null);\n\n      if (uriStr == null)\n      {\n        pref.setSummary(\"No file selected\");\n        return;\n      }\n\n      android.net.Uri uri = android.net.Uri.parse(uriStr);\n\n      // Get filename and size from URI\n      String filename = null;\n      long fileSize = 0;\n\n      try (android.database.Cursor cursor = getContentResolver().query(uri, null, null, null, null))\n      {\n        if (cursor != null && cursor.moveToFirst())\n        {\n          int nameIndex = cursor.getColumnIndex(android.provider.OpenableColumns.DISPLAY_NAME);\n          if (nameIndex >= 0)\n          {\n            filename = cursor.getString(nameIndex);"
  }
}
```