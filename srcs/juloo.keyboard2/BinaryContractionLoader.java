package juloo.keyboard2;

import android.content.Context;
import android.util.Log;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Fast binary contraction loader.
 *
 * Loads contractions from optimized binary format (generated by
 * scripts/generate_binary_contractions.py) instead of parsing JSON at runtime.
 *
 * Performance Benefits:
 * - No JSON parsing overhead (faster startup)
 * - No JSONObject/JSONArray allocations
 * - Direct byte buffer access (memory-efficient)
 * - Single file instead of two JSON files
 *
 * Binary Format V1:
 * -----------------
 * Header (16 bytes):
 *   - Magic: b'CTRB' (4 bytes)
 *   - Version: uint32 (4 bytes)
 *   - Non-paired count: uint32 (4 bytes)
 *   - Paired count: uint32 (4 bytes)
 *
 * Non-Paired Section:
 *   - For each non-paired mapping:
 *     - Key length: uint16 (2 bytes)
 *     - Key UTF-8 bytes
 *     - Value length: uint16 (2 bytes)
 *     - Value UTF-8 bytes
 *
 * Paired Section:
 *   - For each paired contraction:
 *     - Contraction length: uint16 (2 bytes)
 *     - Contraction UTF-8 bytes
 *
 * OPTIMIZATION v1 (perftodos2.md Todo 4): Eliminates slow JSON parsing at startup
 */
public class BinaryContractionLoader
{
  private static final String TAG = "BinaryContractionLoader";
  private static final int MAGIC = 0x42525443; // "CTRB" in little-endian
  private static final int EXPECTED_VERSION = 1;
  private static final int HEADER_SIZE = 16;

  /**
   * Result container for loaded contraction data.
   */
  public static class ContractionData
  {
    public final Map<String, String> nonPairedContractions;
    public final Set<String> knownContractions;

    public ContractionData(Map<String, String> nonPaired, Set<String> known)
    {
      this.nonPairedContractions = nonPaired;
      this.knownContractions = known;
    }
  }

  /**
   * Load contractions from binary format.
   *
   * @param context Android context for asset access
   * @param filename Binary contraction filename in assets
   * @return ContractionData with loaded mappings, or null if loading fails
   */
  public static ContractionData loadContractions(Context context, String filename)
  {
    long startTime = System.currentTimeMillis();

    try
    {
      InputStream is = context.getAssets().open(filename);
      ReadableByteChannel channel = Channels.newChannel(is);

      // Read entire file into byte buffer for fast access
      ByteBuffer buffer = ByteBuffer.allocate(is.available());
      buffer.order(ByteOrder.LITTLE_ENDIAN);
      channel.read(buffer);
      buffer.flip();
      channel.close();
      is.close();

      // Parse header
      int magic = buffer.getInt();
      if (magic != MAGIC)
      {
        Log.e(TAG, String.format("Invalid magic number: 0x%08X (expected 0x%08X)", magic, MAGIC));
        return null;
      }

      int version = buffer.getInt();
      if (version != EXPECTED_VERSION)
      {
        Log.e(TAG, String.format("Unsupported version: %d (expected %d)", version, EXPECTED_VERSION));
        return null;
      }

      int nonPairedCount = buffer.getInt();
      int pairedCount = buffer.getInt();

      // Load non-paired contractions
      Map<String, String> nonPaired = new HashMap<>(nonPairedCount);
      Set<String> known = new HashSet<>(nonPairedCount + pairedCount);

      for (int i = 0; i < nonPairedCount; i++)
      {
        String key = readString(buffer);
        String value = readString(buffer);

        nonPaired.put(key, value);
        known.add(value); // Value is the contraction with apostrophe
      }

      // Load paired contractions
      for (int i = 0; i < pairedCount; i++)
      {
        String contraction = readString(buffer);
        known.add(contraction);
      }

      long loadTime = System.currentTimeMillis() - startTime;

      if (BuildConfig.ENABLE_VERBOSE_LOGGING)
      {
        Log.d(TAG, String.format("Loaded %d non-paired, %d total known contractions in %dms",
          nonPaired.size(), known.size(), loadTime));
      }

      return new ContractionData(nonPaired, known);
    }
    catch (IOException e)
    {
      Log.e(TAG, "Failed to load binary contractions", e);
      return null;
    }
  }

  /**
   * Read a length-prefixed UTF-8 string from buffer.
   *
   * @param buffer ByteBuffer to read from
   * @return Decoded string
   */
  private static String readString(ByteBuffer buffer)
  {
    int length = buffer.getShort() & 0xFFFF; // Unsigned short
    byte[] bytes = new byte[length];
    buffer.get(bytes);
    return new String(bytes, StandardCharsets.UTF_8);
  }
}
