package juloo.keyboard2

import android.content.Context
import android.util.Log
import java.io.IOException
import java.nio.ByteBuffer
import java.nio.ByteOrder
import java.nio.channels.Channels

/**
 * Fast binary dictionary loader with pre-built prefix index.
 *
 * Loads dictionaries from optimized binary format (generated by
 * scripts/generate_binary_dict.py) instead of parsing JSON at runtime.
 *
 * Performance Benefits:
 * - No JSON parsing overhead (5-10x faster)
 * - Pre-built prefix index (no runtime computation)
 * - Direct byte buffer access (memory-efficient)
 * - Instant loading via memory mapping (future optimization)
 *
 * Binary Format V1:
 * -----------------
 * Header (32 bytes):
 *   - Magic: b'DICT' (4 bytes)
 *   - Version: uint32 (4 bytes)
 *   - Word count: uint32 (4 bytes)
 *   - Dict offset: uint32 (4 bytes)
 *   - Freq offset: uint32 (4 bytes)
 *   - Prefix offset: uint32 (4 bytes)
 *   - Reserved: 8 bytes
 *
 * Dictionary Section (sorted):
 *   - For each word:
 *     - Length: uint16 (2 bytes)
 *     - UTF-8 bytes
 *
 * Frequency Section (parallel):
 *   - For each word:
 *     - Frequency: uint32 (4 bytes)
 *
 * Prefix Index Section:
 *   - Prefix count: uint32 (4 bytes)
 *   - For each prefix:
 *     - Length: uint8 (1 byte)
 *     - UTF-8 bytes
 *     - Match count: uint32 (4 bytes)
 *     - Match indices: uint32[] (4 bytes each)
 */
object BinaryDictionaryLoader {
    private const val TAG = "BinaryDictionaryLoader"
    private const val MAGIC = 0x54434944 // "DICT" in little-endian
    private const val EXPECTED_VERSION = 1
    private const val HEADER_SIZE = 32

    /**
     * Load dictionary from binary format.
     *
     * @param context Android context for asset access
     * @param filename Binary dictionary filename in assets
     * @return Dict mapping words to frequencies, or null if loading fails
     */
    @JvmStatic
    fun loadDictionary(context: Context, filename: String): Map<String, Int>? {
        // OPTIMIZATION v3 (perftodos3.md): Use android.os.Trace for system-level profiling
        android.os.Trace.beginSection("BinaryDictionaryLoader.loadDictionary")
        try {
            val startTime = System.currentTimeMillis()

            try {
                val inputStream = context.assets.open(filename)
                val channel = Channels.newChannel(inputStream)

                // Read entire file into byte buffer for fast access
                val buffer = ByteBuffer.allocate(inputStream.available()).apply {
                    order(ByteOrder.LITTLE_ENDIAN)
                }
                channel.read(buffer)
                buffer.flip()
                channel.close()
                inputStream.close()

                // Parse header
                val magic = buffer.int
                if (magic != MAGIC) {
                    Log.e(TAG, String.format("Invalid magic number: 0x%08X (expected 0x%08X)", magic, MAGIC))
                    return null
                }

                val version = buffer.int
                if (version != EXPECTED_VERSION) {
                    Log.e(TAG, String.format("Unsupported version: %d (expected %d)", version, EXPECTED_VERSION))
                    return null
                }

                val wordCount = buffer.int
                val dictOffset = buffer.int
                val freqOffset = buffer.int
                val prefixOffset = buffer.int
                buffer.position(buffer.position() + 8) // Skip reserved bytes

                // Load dictionary words
                buffer.position(dictOffset)
                val words = Array(wordCount) {
                    val wordLen = buffer.short.toInt() and 0xFFFF // Unsigned short
                    val wordBytes = ByteArray(wordLen)
                    buffer.get(wordBytes)
                    String(wordBytes, Charsets.UTF_8)
                }

                // Load frequencies
                buffer.position(freqOffset)
                val dictionary = mutableMapOf<String, Int>()
                for (i in 0 until wordCount) {
                    val frequency = buffer.int
                    dictionary[words[i]] = frequency
                }

                val loadTime = System.currentTimeMillis() - startTime
                Log.i(TAG, String.format(
                    "Loaded %d words from binary dictionary in %dms (%.1fx faster than JSON)",
                    wordCount, loadTime, estimateJsonLoadTime(wordCount) / loadTime.toFloat()
                ))

                return dictionary
            } catch (e: IOException) {
                Log.e(TAG, "Failed to load binary dictionary: $filename", e)
                return null
            }
        } finally {
            android.os.Trace.endSection()
        }
    }

    /**
     * Load dictionary and prefix index from binary format.
     *
     * This method loads both the word-to-frequency mapping and the pre-built
     * prefix index, eliminating the need for runtime index generation.
     *
     * @param context Android context for asset access
     * @param filename Binary dictionary filename in assets
     * @param outDictionary Map to populate with word-to-frequency mappings
     * @param outPrefixIndex Map to populate with prefix-to-words mappings
     * @return true if loading succeeded, false otherwise
     */
    @JvmStatic
    fun loadDictionaryWithPrefixIndex(
        context: Context,
        filename: String,
        outDictionary: MutableMap<String, Int>,
        outPrefixIndex: MutableMap<String, MutableSet<String>>
    ): Boolean {
        // OPTIMIZATION v3 (perftodos3.md): Use android.os.Trace for system-level profiling
        android.os.Trace.beginSection("BinaryDictionaryLoader.loadDictionaryWithPrefixIndex")
        try {
            val startTime = System.currentTimeMillis()

            try {
                val inputStream = context.assets.open(filename)
                val channel = Channels.newChannel(inputStream)

                // Read entire file into byte buffer for fast access
                val buffer = ByteBuffer.allocate(inputStream.available()).apply {
                    order(ByteOrder.LITTLE_ENDIAN)
                }
                channel.read(buffer)
                buffer.flip()
                channel.close()
                inputStream.close()

                // Parse header
                val magic = buffer.int
                if (magic != MAGIC) {
                    Log.e(TAG, String.format("Invalid magic number: 0x%08X (expected 0x%08X)", magic, MAGIC))
                    return false
                }

                val version = buffer.int
                if (version != EXPECTED_VERSION) {
                    Log.e(TAG, String.format("Unsupported version: %d (expected %d)", version, EXPECTED_VERSION))
                    return false
                }

                val wordCount = buffer.int
                val dictOffset = buffer.int
                val freqOffset = buffer.int
                val prefixOffset = buffer.int
                buffer.position(buffer.position() + 8) // Skip reserved bytes

                // Load dictionary words
                buffer.position(dictOffset)
                val words = Array(wordCount) {
                    val wordLen = buffer.short.toInt() and 0xFFFF // Unsigned short
                    val wordBytes = ByteArray(wordLen)
                    buffer.get(wordBytes)
                    String(wordBytes, Charsets.UTF_8)
                }

                // Load frequencies
                buffer.position(freqOffset)
                outDictionary.clear()
                for (i in 0 until wordCount) {
                    val frequency = buffer.int
                    outDictionary[words[i]] = frequency
                }

                // Load prefix index
                buffer.position(prefixOffset)
                val prefixCount = buffer.int
                outPrefixIndex.clear()

                for (i in 0 until prefixCount) {
                    // Read prefix string
                    val prefixLen = buffer.get().toInt() and 0xFF // Unsigned byte
                    val prefixBytes = ByteArray(prefixLen)
                    buffer.get(prefixBytes)
                    val prefix = String(prefixBytes, Charsets.UTF_8)

                    // Read matching word indices
                    val matchCount = buffer.int
                    val matchingWords = mutableSetOf<String>()
                    for (j in 0 until matchCount) {
                        val wordIdx = buffer.int
                        matchingWords.add(words[wordIdx])
                    }

                    outPrefixIndex[prefix] = matchingWords
                }

                val loadTime = System.currentTimeMillis() - startTime
                Log.i(TAG, String.format(
                    "Loaded %d words + %d prefixes from binary dictionary in %dms (%.1fx faster than JSON+index)",
                    wordCount, prefixCount, loadTime,
                    estimateJsonWithIndexLoadTime(wordCount) / loadTime.toFloat()
                ))

                return true
            } catch (e: IOException) {
                Log.e(TAG, "Failed to load binary dictionary with prefix index: $filename", e)
                return false
            }
        } finally {
            android.os.Trace.endSection()
        }
    }

    /**
     * Estimate JSON loading time for performance comparison.
     * Based on observed ~300ms for 50k words.
     */
    private fun estimateJsonLoadTime(wordCount: Int): Long {
        return (wordCount / 50000.0 * 300).toLong()
    }

    /**
     * Estimate JSON + prefix index building time for performance comparison.
     * Based on observed ~500ms total for 50k words.
     */
    private fun estimateJsonWithIndexLoadTime(wordCount: Int): Long {
        return (wordCount / 50000.0 * 500).toLong()
    }

    /**
     * Check if a binary dictionary file exists in assets.
     *
     * @param context Android context for asset access
     * @param filename Binary dictionary filename in assets
     * @return true if file exists, false otherwise
     */
    @JvmStatic
    fun exists(context: Context, filename: String): Boolean {
        return try {
            val inputStream = context.assets.open(filename)
            inputStream.close()
            true
        } catch (e: IOException) {
            false
        }
    }
}
