package juloo.keyboard2;

import android.content.Context;
import android.util.Log;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Fast binary dictionary loader with pre-built prefix index.
 *
 * Loads dictionaries from optimized binary format (generated by
 * scripts/generate_binary_dict.py) instead of parsing JSON at runtime.
 *
 * Performance Benefits:
 * - No JSON parsing overhead (5-10x faster)
 * - Pre-built prefix index (no runtime computation)
 * - Direct byte buffer access (memory-efficient)
 * - Instant loading via memory mapping (future optimization)
 *
 * Binary Format V1:
 * -----------------
 * Header (32 bytes):
 *   - Magic: b'DICT' (4 bytes)
 *   - Version: uint32 (4 bytes)
 *   - Word count: uint32 (4 bytes)
 *   - Dict offset: uint32 (4 bytes)
 *   - Freq offset: uint32 (4 bytes)
 *   - Prefix offset: uint32 (4 bytes)
 *   - Reserved: 8 bytes
 *
 * Dictionary Section (sorted):
 *   - For each word:
 *     - Length: uint16 (2 bytes)
 *     - UTF-8 bytes
 *
 * Frequency Section (parallel):
 *   - For each word:
 *     - Frequency: uint32 (4 bytes)
 *
 * Prefix Index Section:
 *   - Prefix count: uint32 (4 bytes)
 *   - For each prefix:
 *     - Length: uint8 (1 byte)
 *     - UTF-8 bytes
 *     - Match count: uint32 (4 bytes)
 *     - Match indices: uint32[] (4 bytes each)
 */
public class BinaryDictionaryLoader
{
  private static final String TAG = "BinaryDictionaryLoader";
  private static final int MAGIC = 0x54434944; // "DICT" in little-endian
  private static final int EXPECTED_VERSION = 1;
  private static final int HEADER_SIZE = 32;

  /**
   * Load dictionary from binary format.
   *
   * @param context Android context for asset access
   * @param filename Binary dictionary filename in assets
   * @return Dict mapping words to frequencies, or null if loading fails
   */
  public static Map<String, Integer> loadDictionary(Context context, String filename)
  {
    // OPTIMIZATION v3 (perftodos3.md): Use android.os.Trace for system-level profiling
    android.os.Trace.beginSection("BinaryDictionaryLoader.loadDictionary");
    try {

    long startTime = System.currentTimeMillis();

    try
    {
      InputStream is = context.getAssets().open(filename);
      ReadableByteChannel channel = Channels.newChannel(is);

      // Read entire file into byte buffer for fast access
      ByteBuffer buffer = ByteBuffer.allocate(is.available());
      buffer.order(ByteOrder.LITTLE_ENDIAN);
      channel.read(buffer);
      buffer.flip();
      channel.close();
      is.close();

      // Parse header
      int magic = buffer.getInt();
      if (magic != MAGIC)
      {
        Log.e(TAG, String.format("Invalid magic number: 0x%08X (expected 0x%08X)", magic, MAGIC));
        return null;
      }

      int version = buffer.getInt();
      if (version != EXPECTED_VERSION)
      {
        Log.e(TAG, String.format("Unsupported version: %d (expected %d)", version, EXPECTED_VERSION));
        return null;
      }

      int wordCount = buffer.getInt();
      int dictOffset = buffer.getInt();
      int freqOffset = buffer.getInt();
      int prefixOffset = buffer.getInt();
      buffer.position(buffer.position() + 8); // Skip reserved bytes

      // Load dictionary words
      buffer.position(dictOffset);
      String[] words = new String[wordCount];
      for (int i = 0; i < wordCount; i++)
      {
        int wordLen = buffer.getShort() & 0xFFFF; // Unsigned short
        byte[] wordBytes = new byte[wordLen];
        buffer.get(wordBytes);
        words[i] = new String(wordBytes, "UTF-8");
      }

      // Load frequencies
      buffer.position(freqOffset);
      Map<String, Integer> dictionary = new HashMap<>(wordCount);
      for (int i = 0; i < wordCount; i++)
      {
        int frequency = buffer.getInt();
        dictionary.put(words[i], frequency);
      }

      long loadTime = System.currentTimeMillis() - startTime;
      Log.i(TAG, String.format("Loaded %d words from binary dictionary in %dms (%.1fx faster than JSON)",
        wordCount, loadTime, estimateJsonLoadTime(wordCount) / (float)loadTime));

      return dictionary;
    }
    catch (IOException e)
    {
      Log.e(TAG, "Failed to load binary dictionary: " + filename, e);
      return null;
    }

    } finally {
      android.os.Trace.endSection();
    }
  }

  /**
   * Load dictionary and prefix index from binary format.
   *
   * This method loads both the word-to-frequency mapping and the pre-built
   * prefix index, eliminating the need for runtime index generation.
   *
   * @param context Android context for asset access
   * @param filename Binary dictionary filename in assets
   * @param outDictionary Map to populate with word-to-frequency mappings
   * @param outPrefixIndex Map to populate with prefix-to-words mappings
   * @return true if loading succeeded, false otherwise
   */
  public static boolean loadDictionaryWithPrefixIndex(
    Context context,
    String filename,
    Map<String, Integer> outDictionary,
    Map<String, Set<String>> outPrefixIndex)
  {
    // OPTIMIZATION v3 (perftodos3.md): Use android.os.Trace for system-level profiling
    android.os.Trace.beginSection("BinaryDictionaryLoader.loadDictionaryWithPrefixIndex");
    try {

    long startTime = System.currentTimeMillis();

    try
    {
      InputStream is = context.getAssets().open(filename);
      ReadableByteChannel channel = Channels.newChannel(is);

      // Read entire file into byte buffer for fast access
      ByteBuffer buffer = ByteBuffer.allocate(is.available());
      buffer.order(ByteOrder.LITTLE_ENDIAN);
      channel.read(buffer);
      buffer.flip();
      channel.close();
      is.close();

      // Parse header
      int magic = buffer.getInt();
      if (magic != MAGIC)
      {
        Log.e(TAG, String.format("Invalid magic number: 0x%08X (expected 0x%08X)", magic, MAGIC));
        return false;
      }

      int version = buffer.getInt();
      if (version != EXPECTED_VERSION)
      {
        Log.e(TAG, String.format("Unsupported version: %d (expected %d)", version, EXPECTED_VERSION));
        return false;
      }

      int wordCount = buffer.getInt();
      int dictOffset = buffer.getInt();
      int freqOffset = buffer.getInt();
      int prefixOffset = buffer.getInt();
      buffer.position(buffer.position() + 8); // Skip reserved bytes

      // Load dictionary words
      buffer.position(dictOffset);
      String[] words = new String[wordCount];
      for (int i = 0; i < wordCount; i++)
      {
        int wordLen = buffer.getShort() & 0xFFFF; // Unsigned short
        byte[] wordBytes = new byte[wordLen];
        buffer.get(wordBytes);
        words[i] = new String(wordBytes, "UTF-8");
      }

      // Load frequencies
      buffer.position(freqOffset);
      outDictionary.clear();
      for (int i = 0; i < wordCount; i++)
      {
        int frequency = buffer.getInt();
        outDictionary.put(words[i], frequency);
      }

      // Load prefix index
      buffer.position(prefixOffset);
      int prefixCount = buffer.getInt();
      outPrefixIndex.clear();

      for (int i = 0; i < prefixCount; i++)
      {
        // Read prefix string
        int prefixLen = buffer.get() & 0xFF; // Unsigned byte
        byte[] prefixBytes = new byte[prefixLen];
        buffer.get(prefixBytes);
        String prefix = new String(prefixBytes, "UTF-8");

        // Read matching word indices
        int matchCount = buffer.getInt();
        Set<String> matchingWords = new HashSet<>(matchCount);
        for (int j = 0; j < matchCount; j++)
        {
          int wordIdx = buffer.getInt();
          matchingWords.add(words[wordIdx]);
        }

        outPrefixIndex.put(prefix, matchingWords);
      }

      long loadTime = System.currentTimeMillis() - startTime;
      Log.i(TAG, String.format(
        "Loaded %d words + %d prefixes from binary dictionary in %dms (%.1fx faster than JSON+index)",
        wordCount, prefixCount, loadTime,
        estimateJsonWithIndexLoadTime(wordCount) / (float)loadTime));

      return true;
    }
    catch (IOException e)
    {
      Log.e(TAG, "Failed to load binary dictionary with prefix index: " + filename, e);
      return false;
    }

    } finally {
      android.os.Trace.endSection();
    }
  }

  /**
   * Estimate JSON loading time for performance comparison.
   * Based on observed ~300ms for 50k words.
   */
  private static long estimateJsonLoadTime(int wordCount)
  {
    return (long)(wordCount / 50000.0 * 300);
  }

  /**
   * Estimate JSON + prefix index building time for performance comparison.
   * Based on observed ~500ms total for 50k words.
   */
  private static long estimateJsonWithIndexLoadTime(int wordCount)
  {
    return (long)(wordCount / 50000.0 * 500);
  }

  /**
   * Check if a binary dictionary file exists in assets.
   *
   * @param context Android context for asset access
   * @param filename Binary dictionary filename in assets
   * @return true if file exists, false otherwise
   */
  public static boolean exists(Context context, String filename)
  {
    try
    {
      InputStream is = context.getAssets().open(filename);
      is.close();
      return true;
    }
    catch (IOException e)
    {
      return false;
    }
  }
}
